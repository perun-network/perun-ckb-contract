// Generated by Molecule 0.7.3
#![allow(unused_imports)]

#[cfg(feature = "std")]
use {ckb_types::packed::*, ckb_types::prelude::*};

#[cfg(not(feature = "std"))]
use {ckb_standalone_types::packed::*, ckb_standalone_types::prelude::*};

use molecule::prelude::*;

#[derive(Clone)]
pub struct SEC1EncodedPubKey(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SEC1EncodedPubKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SEC1EncodedPubKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SEC1EncodedPubKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for SEC1EncodedPubKey {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0,
        ];
        SEC1EncodedPubKey::new_unchecked(v.into())
    }
}
impl SEC1EncodedPubKey {
    pub const TOTAL_SIZE: usize = 33;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 33;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn nth32(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(32..33))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> SEC1EncodedPubKeyReader<'r> {
        SEC1EncodedPubKeyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SEC1EncodedPubKey {
    type Builder = SEC1EncodedPubKeyBuilder;
    const NAME: &'static str = "SEC1EncodedPubKey";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SEC1EncodedPubKey(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SEC1EncodedPubKeyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SEC1EncodedPubKeyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct SEC1EncodedPubKeyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SEC1EncodedPubKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SEC1EncodedPubKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SEC1EncodedPubKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> SEC1EncodedPubKeyReader<'r> {
    pub const TOTAL_SIZE: usize = 33;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 33;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn nth32(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[32..33])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for SEC1EncodedPubKeyReader<'r> {
    type Entity = SEC1EncodedPubKey;
    const NAME: &'static str = "SEC1EncodedPubKeyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SEC1EncodedPubKeyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct SEC1EncodedPubKeyBuilder(pub(crate) [Byte; 33]);
impl ::core::fmt::Debug for SEC1EncodedPubKeyBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for SEC1EncodedPubKeyBuilder {
    fn default() -> Self {
        SEC1EncodedPubKeyBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl SEC1EncodedPubKeyBuilder {
    pub const TOTAL_SIZE: usize = 33;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 33;
    pub fn set(mut self, v: [Byte; 33]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
    pub fn nth32(mut self, v: Byte) -> Self {
        self.0[32] = v;
        self
    }
}
impl molecule::prelude::Builder for SEC1EncodedPubKeyBuilder {
    type Entity = SEC1EncodedPubKey;
    const NAME: &'static str = "SEC1EncodedPubKeyBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SEC1EncodedPubKey::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CKByteDistribution(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CKByteDistribution {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CKByteDistribution {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CKByteDistribution {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for CKByteDistribution {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        CKByteDistribution::new_unchecked(v.into())
    }
}
impl CKByteDistribution {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 8;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn nth1(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(8..16))
    }
    pub fn as_reader<'r>(&'r self) -> CKByteDistributionReader<'r> {
        CKByteDistributionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CKByteDistribution {
    type Builder = CKByteDistributionBuilder;
    const NAME: &'static str = "CKByteDistribution";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CKByteDistribution(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CKByteDistributionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CKByteDistributionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
#[derive(Clone, Copy)]
pub struct CKByteDistributionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CKByteDistributionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CKByteDistributionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CKByteDistributionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl<'r> CKByteDistributionReader<'r> {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 8;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn nth1(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[8..16])
    }
}
impl<'r> molecule::prelude::Reader<'r> for CKByteDistributionReader<'r> {
    type Entity = CKByteDistribution;
    const NAME: &'static str = "CKByteDistributionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CKByteDistributionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct CKByteDistributionBuilder(pub(crate) [Uint64; 2]);
impl ::core::fmt::Debug for CKByteDistributionBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for CKByteDistributionBuilder {
    fn default() -> Self {
        CKByteDistributionBuilder([Uint64::default(), Uint64::default()])
    }
}
impl CKByteDistributionBuilder {
    pub const TOTAL_SIZE: usize = 16;
    pub const ITEM_SIZE: usize = 8;
    pub const ITEM_COUNT: usize = 2;
    pub fn set(mut self, v: [Uint64; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Uint64) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Uint64) -> Self {
        self.0[1] = v;
        self
    }
}
impl molecule::prelude::Builder for CKByteDistributionBuilder {
    type Entity = CKByteDistribution;
    const NAME: &'static str = "CKByteDistributionBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CKByteDistribution::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SUDTDistribution(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SUDTDistribution {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SUDTDistribution {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SUDTDistribution {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for SUDTDistribution {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ];
        SUDTDistribution::new_unchecked(v.into())
    }
}
impl SUDTDistribution {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 16;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Uint128 {
        Uint128::new_unchecked(self.0.slice(0..16))
    }
    pub fn nth1(&self) -> Uint128 {
        Uint128::new_unchecked(self.0.slice(16..32))
    }
    pub fn as_reader<'r>(&'r self) -> SUDTDistributionReader<'r> {
        SUDTDistributionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SUDTDistribution {
    type Builder = SUDTDistributionBuilder;
    const NAME: &'static str = "SUDTDistribution";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SUDTDistribution(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SUDTDistributionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SUDTDistributionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
#[derive(Clone, Copy)]
pub struct SUDTDistributionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SUDTDistributionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SUDTDistributionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SUDTDistributionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl<'r> SUDTDistributionReader<'r> {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 16;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Uint128Reader<'r> {
        Uint128Reader::new_unchecked(&self.as_slice()[0..16])
    }
    pub fn nth1(&self) -> Uint128Reader<'r> {
        Uint128Reader::new_unchecked(&self.as_slice()[16..32])
    }
}
impl<'r> molecule::prelude::Reader<'r> for SUDTDistributionReader<'r> {
    type Entity = SUDTDistribution;
    const NAME: &'static str = "SUDTDistributionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SUDTDistributionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct SUDTDistributionBuilder(pub(crate) [Uint128; 2]);
impl ::core::fmt::Debug for SUDTDistributionBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for SUDTDistributionBuilder {
    fn default() -> Self {
        SUDTDistributionBuilder([Uint128::default(), Uint128::default()])
    }
}
impl SUDTDistributionBuilder {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 16;
    pub const ITEM_COUNT: usize = 2;
    pub fn set(mut self, v: [Uint128; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Uint128) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Uint128) -> Self {
        self.0[1] = v;
        self
    }
}
impl molecule::prelude::Builder for SUDTDistributionBuilder {
    type Entity = SUDTDistribution;
    const NAME: &'static str = "SUDTDistributionBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SUDTDistribution::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SUDTAllocation(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SUDTAllocation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SUDTAllocation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SUDTAllocation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for SUDTAllocation {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        SUDTAllocation::new_unchecked(v.into())
    }
}
impl SUDTAllocation {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<SUDTBalances> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> SUDTBalances {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            SUDTBalances::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            SUDTBalances::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SUDTAllocationReader<'r> {
        SUDTAllocationReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SUDTAllocation {
    type Builder = SUDTAllocationBuilder;
    const NAME: &'static str = "SUDTAllocation";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SUDTAllocation(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SUDTAllocationReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SUDTAllocationReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct SUDTAllocationReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SUDTAllocationReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SUDTAllocationReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SUDTAllocationReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> SUDTAllocationReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<SUDTBalancesReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> SUDTBalancesReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            SUDTBalancesReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            SUDTBalancesReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SUDTAllocationReader<'r> {
    type Entity = SUDTAllocation;
    const NAME: &'static str = "SUDTAllocationReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SUDTAllocationReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            SUDTBalancesReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SUDTAllocationBuilder(pub(crate) Vec<SUDTBalances>);
impl SUDTAllocationBuilder {
    pub fn set(mut self, v: Vec<SUDTBalances>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: SUDTBalances) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = SUDTBalances>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: SUDTBalances) -> Option<SUDTBalances> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for SUDTAllocationBuilder {
    type Entity = SUDTAllocation;
    const NAME: &'static str = "SUDTAllocationBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SUDTAllocation::new_unchecked(inner.into())
    }
}
pub struct SUDTAllocationIterator(SUDTAllocation, usize, usize);
impl ::core::iter::Iterator for SUDTAllocationIterator {
    type Item = SUDTBalances;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for SUDTAllocationIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for SUDTAllocation {
    type Item = SUDTBalances;
    type IntoIter = SUDTAllocationIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        SUDTAllocationIterator(self, 0, len)
    }
}
impl<'r> SUDTAllocationReader<'r> {
    pub fn iter<'t>(&'t self) -> SUDTAllocationReaderIterator<'t, 'r> {
        SUDTAllocationReaderIterator(&self, 0, self.len())
    }
}
pub struct SUDTAllocationReaderIterator<'t, 'r>(&'t SUDTAllocationReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for SUDTAllocationReaderIterator<'t, 'r> {
    type Item = SUDTBalancesReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for SUDTAllocationReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct SUDTAsset(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SUDTAsset {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SUDTAsset {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SUDTAsset {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "type_script", self.type_script())?;
        write!(f, ", {}: {}", "max_capacity", self.max_capacity())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SUDTAsset {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            73, 0, 0, 0, 12, 0, 0, 0, 65, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        SUDTAsset::new_unchecked(v.into())
    }
}
impl SUDTAsset {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn type_script(&self) -> Script {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Script::new_unchecked(self.0.slice(start..end))
    }
    pub fn max_capacity(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Uint64::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SUDTAssetReader<'r> {
        SUDTAssetReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SUDTAsset {
    type Builder = SUDTAssetBuilder;
    const NAME: &'static str = "SUDTAsset";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SUDTAsset(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SUDTAssetReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SUDTAssetReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .type_script(self.type_script())
            .max_capacity(self.max_capacity())
    }
}
#[derive(Clone, Copy)]
pub struct SUDTAssetReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SUDTAssetReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SUDTAssetReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SUDTAssetReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "type_script", self.type_script())?;
        write!(f, ", {}: {}", "max_capacity", self.max_capacity())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SUDTAssetReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn type_script(&self) -> ScriptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ScriptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn max_capacity(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Uint64Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SUDTAssetReader<'r> {
    type Entity = SUDTAsset;
    const NAME: &'static str = "SUDTAssetReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SUDTAssetReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ScriptReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SUDTAssetBuilder {
    pub(crate) type_script: Script,
    pub(crate) max_capacity: Uint64,
}
impl SUDTAssetBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn type_script(mut self, v: Script) -> Self {
        self.type_script = v;
        self
    }
    pub fn max_capacity(mut self, v: Uint64) -> Self {
        self.max_capacity = v;
        self
    }
}
impl molecule::prelude::Builder for SUDTAssetBuilder {
    type Entity = SUDTAsset;
    const NAME: &'static str = "SUDTAssetBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.type_script.as_slice().len()
            + self.max_capacity.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.type_script.as_slice().len();
        offsets.push(total_size);
        total_size += self.max_capacity.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.type_script.as_slice())?;
        writer.write_all(self.max_capacity.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SUDTAsset::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SUDTBalances(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SUDTBalances {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SUDTBalances {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SUDTBalances {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "asset", self.asset())?;
        write!(f, ", {}: {}", "distribution", self.distribution())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SUDTBalances {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            117, 0, 0, 0, 12, 0, 0, 0, 85, 0, 0, 0, 73, 0, 0, 0, 12, 0, 0, 0, 65, 0, 0, 0, 53, 0,
            0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0,
        ];
        SUDTBalances::new_unchecked(v.into())
    }
}
impl SUDTBalances {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn asset(&self) -> SUDTAsset {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SUDTAsset::new_unchecked(self.0.slice(start..end))
    }
    pub fn distribution(&self) -> SUDTDistribution {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SUDTDistribution::new_unchecked(self.0.slice(start..end))
        } else {
            SUDTDistribution::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SUDTBalancesReader<'r> {
        SUDTBalancesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SUDTBalances {
    type Builder = SUDTBalancesBuilder;
    const NAME: &'static str = "SUDTBalances";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SUDTBalances(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SUDTBalancesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SUDTBalancesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .asset(self.asset())
            .distribution(self.distribution())
    }
}
#[derive(Clone, Copy)]
pub struct SUDTBalancesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SUDTBalancesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SUDTBalancesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SUDTBalancesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "asset", self.asset())?;
        write!(f, ", {}: {}", "distribution", self.distribution())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SUDTBalancesReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn asset(&self) -> SUDTAssetReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SUDTAssetReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn distribution(&self) -> SUDTDistributionReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SUDTDistributionReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SUDTDistributionReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SUDTBalancesReader<'r> {
    type Entity = SUDTBalances;
    const NAME: &'static str = "SUDTBalancesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SUDTBalancesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        SUDTAssetReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SUDTDistributionReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SUDTBalancesBuilder {
    pub(crate) asset: SUDTAsset,
    pub(crate) distribution: SUDTDistribution,
}
impl SUDTBalancesBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn asset(mut self, v: SUDTAsset) -> Self {
        self.asset = v;
        self
    }
    pub fn distribution(mut self, v: SUDTDistribution) -> Self {
        self.distribution = v;
        self
    }
}
impl molecule::prelude::Builder for SUDTBalancesBuilder {
    type Entity = SUDTBalances;
    const NAME: &'static str = "SUDTBalancesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.asset.as_slice().len()
            + self.distribution.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.asset.as_slice().len();
        offsets.push(total_size);
        total_size += self.distribution.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.asset.as_slice())?;
        writer.write_all(self.distribution.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SUDTBalances::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Balances(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Balances {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Balances {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Balances {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "ckbytes", self.ckbytes())?;
        write!(f, ", {}: {}", "sudts", self.sudts())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Balances {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            32, 0, 0, 0, 12, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            4, 0, 0, 0,
        ];
        Balances::new_unchecked(v.into())
    }
}
impl Balances {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn ckbytes(&self) -> CKByteDistribution {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        CKByteDistribution::new_unchecked(self.0.slice(start..end))
    }
    pub fn sudts(&self) -> SUDTAllocation {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SUDTAllocation::new_unchecked(self.0.slice(start..end))
        } else {
            SUDTAllocation::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BalancesReader<'r> {
        BalancesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Balances {
    type Builder = BalancesBuilder;
    const NAME: &'static str = "Balances";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Balances(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BalancesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BalancesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .ckbytes(self.ckbytes())
            .sudts(self.sudts())
    }
}
#[derive(Clone, Copy)]
pub struct BalancesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BalancesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BalancesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BalancesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "ckbytes", self.ckbytes())?;
        write!(f, ", {}: {}", "sudts", self.sudts())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BalancesReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn ckbytes(&self) -> CKByteDistributionReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        CKByteDistributionReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sudts(&self) -> SUDTAllocationReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SUDTAllocationReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SUDTAllocationReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BalancesReader<'r> {
    type Entity = Balances;
    const NAME: &'static str = "BalancesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BalancesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        CKByteDistributionReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SUDTAllocationReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BalancesBuilder {
    pub(crate) ckbytes: CKByteDistribution,
    pub(crate) sudts: SUDTAllocation,
}
impl BalancesBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn ckbytes(mut self, v: CKByteDistribution) -> Self {
        self.ckbytes = v;
        self
    }
    pub fn sudts(mut self, v: SUDTAllocation) -> Self {
        self.sudts = v;
        self
    }
}
impl molecule::prelude::Builder for BalancesBuilder {
    type Entity = Balances;
    const NAME: &'static str = "BalancesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.ckbytes.as_slice().len()
            + self.sudts.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.ckbytes.as_slice().len();
        offsets.push(total_size);
        total_size += self.sudts.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.ckbytes.as_slice())?;
        writer.write_all(self.sudts.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Balances::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct True(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for True {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for True {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for True {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for True {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        True::new_unchecked(v.into())
    }
}
impl True {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> TrueReader<'r> {
        TrueReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for True {
    type Builder = TrueBuilder;
    const NAME: &'static str = "True";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        True(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TrueReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TrueReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct TrueReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TrueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TrueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TrueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> TrueReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for TrueReader<'r> {
    type Entity = True;
    const NAME: &'static str = "TrueReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TrueReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct TrueBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for TrueBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for TrueBuilder {
    fn default() -> Self {
        TrueBuilder([Byte::default()])
    }
}
impl TrueBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for TrueBuilder {
    type Entity = True;
    const NAME: &'static str = "TrueBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        True::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct False(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for False {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for False {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for False {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for False {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        False::new_unchecked(v.into())
    }
}
impl False {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> FalseReader<'r> {
        FalseReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for False {
    type Builder = FalseBuilder;
    const NAME: &'static str = "False";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        False(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FalseReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FalseReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct FalseReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FalseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FalseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FalseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> FalseReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for FalseReader<'r> {
    type Entity = False;
    const NAME: &'static str = "FalseReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FalseReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct FalseBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for FalseBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for FalseBuilder {
    fn default() -> Self {
        FalseBuilder([Byte::default()])
    }
}
impl FalseBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for FalseBuilder {
    type Entity = False;
    const NAME: &'static str = "FalseBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        False::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Bool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Bool {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0];
        Bool::new_unchecked(v.into())
    }
}
impl Bool {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BoolUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => True::new_unchecked(inner).into(),
            1 => False::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> BoolReader<'r> {
        BoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Bool {
    type Builder = BoolBuilder;
    const NAME: &'static str = "Bool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct BoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> BoolReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BoolUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => TrueReader::new_unchecked(inner).into(),
            1 => FalseReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BoolReader<'r> {
    type Entity = Bool;
    const NAME: &'static str = "BoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => TrueReader::verify(inner_slice, compatible),
            1 => FalseReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BoolBuilder(pub(crate) BoolUnion);
impl BoolBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<BoolUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for BoolBuilder {
    type Entity = Bool;
    const NAME: &'static str = "BoolBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Bool::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum BoolUnion {
    True(True),
    False(False),
}
#[derive(Debug, Clone, Copy)]
pub enum BoolUnionReader<'r> {
    True(TrueReader<'r>),
    False(FalseReader<'r>),
}
impl ::core::default::Default for BoolUnion {
    fn default() -> Self {
        BoolUnion::True(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for BoolUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BoolUnion::True(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, True::NAME, item)
            }
            BoolUnion::False(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, False::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for BoolUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BoolUnionReader::True(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, True::NAME, item)
            }
            BoolUnionReader::False(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, False::NAME, item)
            }
        }
    }
}
impl BoolUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BoolUnion::True(ref item) => write!(f, "{}", item),
            BoolUnion::False(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> BoolUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BoolUnionReader::True(ref item) => write!(f, "{}", item),
            BoolUnionReader::False(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<True> for BoolUnion {
    fn from(item: True) -> Self {
        BoolUnion::True(item)
    }
}
impl ::core::convert::From<False> for BoolUnion {
    fn from(item: False) -> Self {
        BoolUnion::False(item)
    }
}
impl<'r> ::core::convert::From<TrueReader<'r>> for BoolUnionReader<'r> {
    fn from(item: TrueReader<'r>) -> Self {
        BoolUnionReader::True(item)
    }
}
impl<'r> ::core::convert::From<FalseReader<'r>> for BoolUnionReader<'r> {
    fn from(item: FalseReader<'r>) -> Self {
        BoolUnionReader::False(item)
    }
}
impl BoolUnion {
    pub const NAME: &'static str = "BoolUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            BoolUnion::True(item) => item.as_bytes(),
            BoolUnion::False(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            BoolUnion::True(item) => item.as_slice(),
            BoolUnion::False(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BoolUnion::True(_) => 0,
            BoolUnion::False(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BoolUnion::True(_) => "True",
            BoolUnion::False(_) => "False",
        }
    }
    pub fn as_reader<'r>(&'r self) -> BoolUnionReader<'r> {
        match self {
            BoolUnion::True(item) => item.as_reader().into(),
            BoolUnion::False(item) => item.as_reader().into(),
        }
    }
}
impl<'r> BoolUnionReader<'r> {
    pub const NAME: &'r str = "BoolUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            BoolUnionReader::True(item) => item.as_slice(),
            BoolUnionReader::False(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BoolUnionReader::True(_) => 0,
            BoolUnionReader::False(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BoolUnionReader::True(_) => "True",
            BoolUnionReader::False(_) => "False",
        }
    }
}
#[derive(Clone)]
pub struct A(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for A {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for A {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for A {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for A {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        A::new_unchecked(v.into())
    }
}
impl A {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> AReader<'r> {
        AReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for A {
    type Builder = ABuilder;
    const NAME: &'static str = "A";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        A(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct AReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> AReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for AReader<'r> {
    type Entity = A;
    const NAME: &'static str = "AReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct ABuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for ABuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for ABuilder {
    fn default() -> Self {
        ABuilder([Byte::default()])
    }
}
impl ABuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for ABuilder {
    type Entity = A;
    const NAME: &'static str = "ABuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        A::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct B(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for B {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for B {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for B {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for B {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        B::new_unchecked(v.into())
    }
}
impl B {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> BReader<'r> {
        BReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for B {
    type Builder = BBuilder;
    const NAME: &'static str = "B";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        B(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct BReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for BReader<'r> {
    type Entity = B;
    const NAME: &'static str = "BReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for BBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BBuilder {
    fn default() -> Self {
        BBuilder([Byte::default()])
    }
}
impl BBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for BBuilder {
    type Entity = B;
    const NAME: &'static str = "BBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        B::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct App(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for App {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for App {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for App {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for App {
    fn default() -> Self {
        let v: Vec<u8> = vec![];
        App::new_unchecked(v.into())
    }
}
impl App {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Bytes> {
        if self.is_none() {
            None
        } else {
            Some(Bytes::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AppReader<'r> {
        AppReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for App {
    type Builder = AppBuilder;
    const NAME: &'static str = "App";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        App(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AppReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AppReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct AppReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AppReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AppReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AppReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> AppReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<BytesReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(BytesReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AppReader<'r> {
    type Entity = App;
    const NAME: &'static str = "AppReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AppReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            BytesReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct AppBuilder(pub(crate) Option<Bytes>);
impl AppBuilder {
    pub fn set(mut self, v: Option<Bytes>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for AppBuilder {
    type Entity = App;
    const NAME: &'static str = "AppBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        App::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Participant(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Participant {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Participant {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Participant {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "payment_script_hash",
            self.payment_script_hash()
        )?;
        write!(
            f,
            ", {}: {}",
            "payment_min_capacity",
            self.payment_min_capacity()
        )?;
        write!(
            f,
            ", {}: {}",
            "unlock_script_hash",
            self.unlock_script_hash()
        )?;
        write!(f, ", {}: {}", "pub_key", self.pub_key())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Participant {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            125, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        Participant::new_unchecked(v.into())
    }
}
impl Participant {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn payment_script_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn payment_min_capacity(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn unlock_script_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn pub_key(&self) -> SEC1EncodedPubKey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            SEC1EncodedPubKey::new_unchecked(self.0.slice(start..end))
        } else {
            SEC1EncodedPubKey::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ParticipantReader<'r> {
        ParticipantReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Participant {
    type Builder = ParticipantBuilder;
    const NAME: &'static str = "Participant";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Participant(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ParticipantReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ParticipantReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .payment_script_hash(self.payment_script_hash())
            .payment_min_capacity(self.payment_min_capacity())
            .unlock_script_hash(self.unlock_script_hash())
            .pub_key(self.pub_key())
    }
}
#[derive(Clone, Copy)]
pub struct ParticipantReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ParticipantReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ParticipantReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ParticipantReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "payment_script_hash",
            self.payment_script_hash()
        )?;
        write!(
            f,
            ", {}: {}",
            "payment_min_capacity",
            self.payment_min_capacity()
        )?;
        write!(
            f,
            ", {}: {}",
            "unlock_script_hash",
            self.unlock_script_hash()
        )?;
        write!(f, ", {}: {}", "pub_key", self.pub_key())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ParticipantReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn payment_script_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn payment_min_capacity(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn unlock_script_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pub_key(&self) -> SEC1EncodedPubKeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            SEC1EncodedPubKeyReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SEC1EncodedPubKeyReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ParticipantReader<'r> {
    type Entity = Participant;
    const NAME: &'static str = "ParticipantReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ParticipantReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        SEC1EncodedPubKeyReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ParticipantBuilder {
    pub(crate) payment_script_hash: Byte32,
    pub(crate) payment_min_capacity: Uint64,
    pub(crate) unlock_script_hash: Byte32,
    pub(crate) pub_key: SEC1EncodedPubKey,
}
impl ParticipantBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn payment_script_hash(mut self, v: Byte32) -> Self {
        self.payment_script_hash = v;
        self
    }
    pub fn payment_min_capacity(mut self, v: Uint64) -> Self {
        self.payment_min_capacity = v;
        self
    }
    pub fn unlock_script_hash(mut self, v: Byte32) -> Self {
        self.unlock_script_hash = v;
        self
    }
    pub fn pub_key(mut self, v: SEC1EncodedPubKey) -> Self {
        self.pub_key = v;
        self
    }
}
impl molecule::prelude::Builder for ParticipantBuilder {
    type Entity = Participant;
    const NAME: &'static str = "ParticipantBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.payment_script_hash.as_slice().len()
            + self.payment_min_capacity.as_slice().len()
            + self.unlock_script_hash.as_slice().len()
            + self.pub_key.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.payment_script_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.payment_min_capacity.as_slice().len();
        offsets.push(total_size);
        total_size += self.unlock_script_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.pub_key.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.payment_script_hash.as_slice())?;
        writer.write_all(self.payment_min_capacity.as_slice())?;
        writer.write_all(self.unlock_script_hash.as_slice())?;
        writer.write_all(self.pub_key.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Participant::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelParameters(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelParameters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelParameters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelParameters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "party_a", self.party_a())?;
        write!(f, ", {}: {}", "party_b", self.party_b())?;
        write!(f, ", {}: {}", "nonce", self.nonce())?;
        write!(
            f,
            ", {}: {}",
            "challenge_duration",
            self.challenge_duration()
        )?;
        write!(f, ", {}: {}", "app", self.app())?;
        write!(f, ", {}: {}", "is_ledger_channel", self.is_ledger_channel())?;
        write!(
            f,
            ", {}: {}",
            "is_virtual_channel",
            self.is_virtual_channel()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelParameters {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            76, 1, 0, 0, 32, 0, 0, 0, 157, 0, 0, 0, 26, 1, 0, 0, 58, 1, 0, 0, 66, 1, 0, 0, 66, 1,
            0, 0, 71, 1, 0, 0, 125, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0,
            0, 60, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ChannelParameters::new_unchecked(v.into())
    }
}
impl ChannelParameters {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn party_a(&self) -> Participant {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Participant::new_unchecked(self.0.slice(start..end))
    }
    pub fn party_b(&self) -> Participant {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Participant::new_unchecked(self.0.slice(start..end))
    }
    pub fn nonce(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn challenge_duration(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn app(&self) -> App {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        App::new_unchecked(self.0.slice(start..end))
    }
    pub fn is_ledger_channel(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Bool::new_unchecked(self.0.slice(start..end))
    }
    pub fn is_virtual_channel(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            Bool::new_unchecked(self.0.slice(start..end))
        } else {
            Bool::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelParametersReader<'r> {
        ChannelParametersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelParameters {
    type Builder = ChannelParametersBuilder;
    const NAME: &'static str = "ChannelParameters";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelParameters(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelParametersReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelParametersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .party_a(self.party_a())
            .party_b(self.party_b())
            .nonce(self.nonce())
            .challenge_duration(self.challenge_duration())
            .app(self.app())
            .is_ledger_channel(self.is_ledger_channel())
            .is_virtual_channel(self.is_virtual_channel())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelParametersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelParametersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelParametersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelParametersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "party_a", self.party_a())?;
        write!(f, ", {}: {}", "party_b", self.party_b())?;
        write!(f, ", {}: {}", "nonce", self.nonce())?;
        write!(
            f,
            ", {}: {}",
            "challenge_duration",
            self.challenge_duration()
        )?;
        write!(f, ", {}: {}", "app", self.app())?;
        write!(f, ", {}: {}", "is_ledger_channel", self.is_ledger_channel())?;
        write!(
            f,
            ", {}: {}",
            "is_virtual_channel",
            self.is_virtual_channel()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelParametersReader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn party_a(&self) -> ParticipantReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ParticipantReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn party_b(&self) -> ParticipantReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ParticipantReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn nonce(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn challenge_duration(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn app(&self) -> AppReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        AppReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn is_ledger_channel(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BoolReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn is_virtual_channel(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            BoolReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BoolReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelParametersReader<'r> {
    type Entity = ChannelParameters;
    const NAME: &'static str = "ChannelParametersReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelParametersReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ParticipantReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ParticipantReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        AppReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BoolReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        BoolReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelParametersBuilder {
    pub(crate) party_a: Participant,
    pub(crate) party_b: Participant,
    pub(crate) nonce: Byte32,
    pub(crate) challenge_duration: Uint64,
    pub(crate) app: App,
    pub(crate) is_ledger_channel: Bool,
    pub(crate) is_virtual_channel: Bool,
}
impl ChannelParametersBuilder {
    pub const FIELD_COUNT: usize = 7;
    pub fn party_a(mut self, v: Participant) -> Self {
        self.party_a = v;
        self
    }
    pub fn party_b(mut self, v: Participant) -> Self {
        self.party_b = v;
        self
    }
    pub fn nonce(mut self, v: Byte32) -> Self {
        self.nonce = v;
        self
    }
    pub fn challenge_duration(mut self, v: Uint64) -> Self {
        self.challenge_duration = v;
        self
    }
    pub fn app(mut self, v: App) -> Self {
        self.app = v;
        self
    }
    pub fn is_ledger_channel(mut self, v: Bool) -> Self {
        self.is_ledger_channel = v;
        self
    }
    pub fn is_virtual_channel(mut self, v: Bool) -> Self {
        self.is_virtual_channel = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelParametersBuilder {
    type Entity = ChannelParameters;
    const NAME: &'static str = "ChannelParametersBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.party_a.as_slice().len()
            + self.party_b.as_slice().len()
            + self.nonce.as_slice().len()
            + self.challenge_duration.as_slice().len()
            + self.app.as_slice().len()
            + self.is_ledger_channel.as_slice().len()
            + self.is_virtual_channel.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.party_a.as_slice().len();
        offsets.push(total_size);
        total_size += self.party_b.as_slice().len();
        offsets.push(total_size);
        total_size += self.nonce.as_slice().len();
        offsets.push(total_size);
        total_size += self.challenge_duration.as_slice().len();
        offsets.push(total_size);
        total_size += self.app.as_slice().len();
        offsets.push(total_size);
        total_size += self.is_ledger_channel.as_slice().len();
        offsets.push(total_size);
        total_size += self.is_virtual_channel.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.party_a.as_slice())?;
        writer.write_all(self.party_b.as_slice())?;
        writer.write_all(self.nonce.as_slice())?;
        writer.write_all(self.challenge_duration.as_slice())?;
        writer.write_all(self.app.as_slice())?;
        writer.write_all(self.is_ledger_channel.as_slice())?;
        writer.write_all(self.is_virtual_channel.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelParameters::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelConstants(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "params", self.params())?;
        write!(f, ", {}: {}", "pfls_code_hash", self.pfls_code_hash())?;
        write!(f, ", {}: {}", "pfls_hash_type", self.pfls_hash_type())?;
        write!(f, ", {}: {}", "pfls_min_capacity", self.pfls_min_capacity())?;
        write!(f, ", {}: {}", "pcls_code_hash", self.pcls_code_hash())?;
        write!(f, ", {}: {}", "pcls_hash_type", self.pcls_hash_type())?;
        write!(f, ", {}: {}", "thread_token", self.thread_token())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelConstants {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            218, 1, 0, 0, 32, 0, 0, 0, 108, 1, 0, 0, 140, 1, 0, 0, 141, 1, 0, 0, 149, 1, 0, 0, 181,
            1, 0, 0, 182, 1, 0, 0, 76, 1, 0, 0, 32, 0, 0, 0, 157, 0, 0, 0, 26, 1, 0, 0, 58, 1, 0,
            0, 66, 1, 0, 0, 66, 1, 0, 0, 71, 1, 0, 0, 125, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 60,
            0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125, 0, 0,
            0, 20, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ChannelConstants::new_unchecked(v.into())
    }
}
impl ChannelConstants {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn params(&self) -> ChannelParameters {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelParameters::new_unchecked(self.0.slice(start..end))
    }
    pub fn pfls_code_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn pfls_hash_type(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn pfls_min_capacity(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn pcls_code_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn pcls_hash_type(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }
    pub fn thread_token(&self) -> ChannelToken {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            ChannelToken::new_unchecked(self.0.slice(start..end))
        } else {
            ChannelToken::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelConstantsReader<'r> {
        ChannelConstantsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelConstants {
    type Builder = ChannelConstantsBuilder;
    const NAME: &'static str = "ChannelConstants";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelConstants(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelConstantsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelConstantsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .params(self.params())
            .pfls_code_hash(self.pfls_code_hash())
            .pfls_hash_type(self.pfls_hash_type())
            .pfls_min_capacity(self.pfls_min_capacity())
            .pcls_code_hash(self.pcls_code_hash())
            .pcls_hash_type(self.pcls_hash_type())
            .thread_token(self.thread_token())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelConstantsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelConstantsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelConstantsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelConstantsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "params", self.params())?;
        write!(f, ", {}: {}", "pfls_code_hash", self.pfls_code_hash())?;
        write!(f, ", {}: {}", "pfls_hash_type", self.pfls_hash_type())?;
        write!(f, ", {}: {}", "pfls_min_capacity", self.pfls_min_capacity())?;
        write!(f, ", {}: {}", "pcls_code_hash", self.pcls_code_hash())?;
        write!(f, ", {}: {}", "pcls_hash_type", self.pcls_hash_type())?;
        write!(f, ", {}: {}", "thread_token", self.thread_token())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelConstantsReader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn params(&self) -> ChannelParametersReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelParametersReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pfls_code_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pfls_hash_type(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pfls_min_capacity(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pcls_code_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pcls_hash_type(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn thread_token(&self) -> ChannelTokenReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            ChannelTokenReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ChannelTokenReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelConstantsReader<'r> {
    type Entity = ChannelConstants;
    const NAME: &'static str = "ChannelConstantsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelConstantsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ChannelParametersReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ByteReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Byte32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        ByteReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        ChannelTokenReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelConstantsBuilder {
    pub(crate) params: ChannelParameters,
    pub(crate) pfls_code_hash: Byte32,
    pub(crate) pfls_hash_type: Byte,
    pub(crate) pfls_min_capacity: Uint64,
    pub(crate) pcls_code_hash: Byte32,
    pub(crate) pcls_hash_type: Byte,
    pub(crate) thread_token: ChannelToken,
}
impl ChannelConstantsBuilder {
    pub const FIELD_COUNT: usize = 7;
    pub fn params(mut self, v: ChannelParameters) -> Self {
        self.params = v;
        self
    }
    pub fn pfls_code_hash(mut self, v: Byte32) -> Self {
        self.pfls_code_hash = v;
        self
    }
    pub fn pfls_hash_type(mut self, v: Byte) -> Self {
        self.pfls_hash_type = v;
        self
    }
    pub fn pfls_min_capacity(mut self, v: Uint64) -> Self {
        self.pfls_min_capacity = v;
        self
    }
    pub fn pcls_code_hash(mut self, v: Byte32) -> Self {
        self.pcls_code_hash = v;
        self
    }
    pub fn pcls_hash_type(mut self, v: Byte) -> Self {
        self.pcls_hash_type = v;
        self
    }
    pub fn thread_token(mut self, v: ChannelToken) -> Self {
        self.thread_token = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelConstantsBuilder {
    type Entity = ChannelConstants;
    const NAME: &'static str = "ChannelConstantsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.params.as_slice().len()
            + self.pfls_code_hash.as_slice().len()
            + self.pfls_hash_type.as_slice().len()
            + self.pfls_min_capacity.as_slice().len()
            + self.pcls_code_hash.as_slice().len()
            + self.pcls_hash_type.as_slice().len()
            + self.thread_token.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.params.as_slice().len();
        offsets.push(total_size);
        total_size += self.pfls_code_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.pfls_hash_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.pfls_min_capacity.as_slice().len();
        offsets.push(total_size);
        total_size += self.pcls_code_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.pcls_hash_type.as_slice().len();
        offsets.push(total_size);
        total_size += self.thread_token.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.params.as_slice())?;
        writer.write_all(self.pfls_code_hash.as_slice())?;
        writer.write_all(self.pfls_hash_type.as_slice())?;
        writer.write_all(self.pfls_min_capacity.as_slice())?;
        writer.write_all(self.pcls_code_hash.as_slice())?;
        writer.write_all(self.pcls_hash_type.as_slice())?;
        writer.write_all(self.thread_token.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelConstants::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Fund(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Fund {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Fund {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Fund {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Fund {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        Fund::new_unchecked(v.into())
    }
}
impl Fund {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> FundReader<'r> {
        FundReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Fund {
    type Builder = FundBuilder;
    const NAME: &'static str = "Fund";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Fund(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FundReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FundReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct FundReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FundReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FundReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FundReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> FundReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for FundReader<'r> {
    type Entity = Fund;
    const NAME: &'static str = "FundReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FundReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct FundBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for FundBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for FundBuilder {
    fn default() -> Self {
        FundBuilder([Byte::default()])
    }
}
impl FundBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for FundBuilder {
    type Entity = Fund;
    const NAME: &'static str = "FundBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Fund::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Abort(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Abort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Abort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Abort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Abort {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        Abort::new_unchecked(v.into())
    }
}
impl Abort {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> AbortReader<'r> {
        AbortReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Abort {
    type Builder = AbortBuilder;
    const NAME: &'static str = "Abort";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Abort(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AbortReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AbortReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct AbortReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AbortReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AbortReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AbortReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> AbortReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for AbortReader<'r> {
    type Entity = Abort;
    const NAME: &'static str = "AbortReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AbortReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct AbortBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for AbortBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for AbortBuilder {
    fn default() -> Self {
        AbortBuilder([Byte::default()])
    }
}
impl AbortBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for AbortBuilder {
    type Entity = Abort;
    const NAME: &'static str = "AbortBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Abort::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Dispute(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Dispute {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Dispute {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Dispute {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "sig_a", self.sig_a())?;
        write!(f, ", {}: {}", "sig_b", self.sig_b())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Dispute {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        Dispute::new_unchecked(v.into())
    }
}
impl Dispute {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn sig_a(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn sig_b(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> DisputeReader<'r> {
        DisputeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Dispute {
    type Builder = DisputeBuilder;
    const NAME: &'static str = "Dispute";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Dispute(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DisputeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DisputeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().sig_a(self.sig_a()).sig_b(self.sig_b())
    }
}
#[derive(Clone, Copy)]
pub struct DisputeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for DisputeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for DisputeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for DisputeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "sig_a", self.sig_a())?;
        write!(f, ", {}: {}", "sig_b", self.sig_b())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> DisputeReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn sig_a(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sig_b(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for DisputeReader<'r> {
    type Entity = Dispute;
    const NAME: &'static str = "DisputeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DisputeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct DisputeBuilder {
    pub(crate) sig_a: Bytes,
    pub(crate) sig_b: Bytes,
}
impl DisputeBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn sig_a(mut self, v: Bytes) -> Self {
        self.sig_a = v;
        self
    }
    pub fn sig_b(mut self, v: Bytes) -> Self {
        self.sig_b = v;
        self
    }
}
impl molecule::prelude::Builder for DisputeBuilder {
    type Entity = Dispute;
    const NAME: &'static str = "DisputeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.sig_a.as_slice().len()
            + self.sig_b.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.sig_a.as_slice().len();
        offsets.push(total_size);
        total_size += self.sig_b.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.sig_a.as_slice())?;
        writer.write_all(self.sig_b.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Dispute::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Close(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Close {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Close {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Close {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "state", self.state())?;
        write!(f, ", {}: {}", "sig_a", self.sig_a())?;
        write!(f, ", {}: {}", "sig_b", self.sig_b())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Close {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            121, 0, 0, 0, 16, 0, 0, 0, 113, 0, 0, 0, 117, 0, 0, 0, 97, 0, 0, 0, 20, 0, 0, 0, 52, 0,
            0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 12, 0, 0, 0, 28, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        Close::new_unchecked(v.into())
    }
}
impl Close {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn state(&self) -> ChannelState {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelState::new_unchecked(self.0.slice(start..end))
    }
    pub fn sig_a(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn sig_b(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CloseReader<'r> {
        CloseReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Close {
    type Builder = CloseBuilder;
    const NAME: &'static str = "Close";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Close(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CloseReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CloseReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .state(self.state())
            .sig_a(self.sig_a())
            .sig_b(self.sig_b())
    }
}
#[derive(Clone, Copy)]
pub struct CloseReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "state", self.state())?;
        write!(f, ", {}: {}", "sig_a", self.sig_a())?;
        write!(f, ", {}: {}", "sig_b", self.sig_b())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CloseReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn state(&self) -> ChannelStateReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelStateReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sig_a(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sig_b(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CloseReader<'r> {
    type Entity = Close;
    const NAME: &'static str = "CloseReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CloseReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ChannelStateReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CloseBuilder {
    pub(crate) state: ChannelState,
    pub(crate) sig_a: Bytes,
    pub(crate) sig_b: Bytes,
}
impl CloseBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn state(mut self, v: ChannelState) -> Self {
        self.state = v;
        self
    }
    pub fn sig_a(mut self, v: Bytes) -> Self {
        self.sig_a = v;
        self
    }
    pub fn sig_b(mut self, v: Bytes) -> Self {
        self.sig_b = v;
        self
    }
}
impl molecule::prelude::Builder for CloseBuilder {
    type Entity = Close;
    const NAME: &'static str = "CloseBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.state.as_slice().len()
            + self.sig_a.as_slice().len()
            + self.sig_b.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.state.as_slice().len();
        offsets.push(total_size);
        total_size += self.sig_a.as_slice().len();
        offsets.push(total_size);
        total_size += self.sig_b.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.state.as_slice())?;
        writer.write_all(self.sig_a.as_slice())?;
        writer.write_all(self.sig_b.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Close::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ForceClose(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ForceClose {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ForceClose {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ForceClose {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for ForceClose {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        ForceClose::new_unchecked(v.into())
    }
}
impl ForceClose {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> ForceCloseReader<'r> {
        ForceCloseReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ForceClose {
    type Builder = ForceCloseBuilder;
    const NAME: &'static str = "ForceClose";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ForceClose(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ForceCloseReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ForceCloseReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct ForceCloseReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ForceCloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ForceCloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ForceCloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> ForceCloseReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for ForceCloseReader<'r> {
    type Entity = ForceClose;
    const NAME: &'static str = "ForceCloseReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ForceCloseReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct ForceCloseBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for ForceCloseBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for ForceCloseBuilder {
    fn default() -> Self {
        ForceCloseBuilder([Byte::default()])
    }
}
impl ForceCloseBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for ForceCloseBuilder {
    type Entity = ForceClose;
    const NAME: &'static str = "ForceCloseBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ForceClose::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelWitness(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelWitness {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelWitness {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelWitness {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for ChannelWitness {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0];
        ChannelWitness::new_unchecked(v.into())
    }
}
impl ChannelWitness {
    pub const ITEMS_COUNT: usize = 5;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> ChannelWitnessUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => Fund::new_unchecked(inner).into(),
            1 => Abort::new_unchecked(inner).into(),
            2 => Dispute::new_unchecked(inner).into(),
            3 => Close::new_unchecked(inner).into(),
            4 => ForceClose::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelWitnessReader<'r> {
        ChannelWitnessReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelWitness {
    type Builder = ChannelWitnessBuilder;
    const NAME: &'static str = "ChannelWitness";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelWitness(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelWitnessReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelWitnessReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelWitnessReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelWitnessReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelWitnessReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelWitnessReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> ChannelWitnessReader<'r> {
    pub const ITEMS_COUNT: usize = 5;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> ChannelWitnessUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => FundReader::new_unchecked(inner).into(),
            1 => AbortReader::new_unchecked(inner).into(),
            2 => DisputeReader::new_unchecked(inner).into(),
            3 => CloseReader::new_unchecked(inner).into(),
            4 => ForceCloseReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelWitnessReader<'r> {
    type Entity = ChannelWitness;
    const NAME: &'static str = "ChannelWitnessReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelWitnessReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => FundReader::verify(inner_slice, compatible),
            1 => AbortReader::verify(inner_slice, compatible),
            2 => DisputeReader::verify(inner_slice, compatible),
            3 => CloseReader::verify(inner_slice, compatible),
            4 => ForceCloseReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelWitnessBuilder(pub(crate) ChannelWitnessUnion);
impl ChannelWitnessBuilder {
    pub const ITEMS_COUNT: usize = 5;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<ChannelWitnessUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for ChannelWitnessBuilder {
    type Entity = ChannelWitness;
    const NAME: &'static str = "ChannelWitnessBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelWitness::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum ChannelWitnessUnion {
    Fund(Fund),
    Abort(Abort),
    Dispute(Dispute),
    Close(Close),
    ForceClose(ForceClose),
}
#[derive(Debug, Clone, Copy)]
pub enum ChannelWitnessUnionReader<'r> {
    Fund(FundReader<'r>),
    Abort(AbortReader<'r>),
    Dispute(DisputeReader<'r>),
    Close(CloseReader<'r>),
    ForceClose(ForceCloseReader<'r>),
}
impl ::core::default::Default for ChannelWitnessUnion {
    fn default() -> Self {
        ChannelWitnessUnion::Fund(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for ChannelWitnessUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ChannelWitnessUnion::Fund(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Fund::NAME, item)
            }
            ChannelWitnessUnion::Abort(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Abort::NAME, item)
            }
            ChannelWitnessUnion::Dispute(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Dispute::NAME, item)
            }
            ChannelWitnessUnion::Close(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Close::NAME, item)
            }
            ChannelWitnessUnion::ForceClose(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ForceClose::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for ChannelWitnessUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ChannelWitnessUnionReader::Fund(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Fund::NAME, item)
            }
            ChannelWitnessUnionReader::Abort(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Abort::NAME, item)
            }
            ChannelWitnessUnionReader::Dispute(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Dispute::NAME, item)
            }
            ChannelWitnessUnionReader::Close(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Close::NAME, item)
            }
            ChannelWitnessUnionReader::ForceClose(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ForceClose::NAME, item)
            }
        }
    }
}
impl ChannelWitnessUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ChannelWitnessUnion::Fund(ref item) => write!(f, "{}", item),
            ChannelWitnessUnion::Abort(ref item) => write!(f, "{}", item),
            ChannelWitnessUnion::Dispute(ref item) => write!(f, "{}", item),
            ChannelWitnessUnion::Close(ref item) => write!(f, "{}", item),
            ChannelWitnessUnion::ForceClose(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> ChannelWitnessUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ChannelWitnessUnionReader::Fund(ref item) => write!(f, "{}", item),
            ChannelWitnessUnionReader::Abort(ref item) => write!(f, "{}", item),
            ChannelWitnessUnionReader::Dispute(ref item) => write!(f, "{}", item),
            ChannelWitnessUnionReader::Close(ref item) => write!(f, "{}", item),
            ChannelWitnessUnionReader::ForceClose(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Fund> for ChannelWitnessUnion {
    fn from(item: Fund) -> Self {
        ChannelWitnessUnion::Fund(item)
    }
}
impl ::core::convert::From<Abort> for ChannelWitnessUnion {
    fn from(item: Abort) -> Self {
        ChannelWitnessUnion::Abort(item)
    }
}
impl ::core::convert::From<Dispute> for ChannelWitnessUnion {
    fn from(item: Dispute) -> Self {
        ChannelWitnessUnion::Dispute(item)
    }
}
impl ::core::convert::From<Close> for ChannelWitnessUnion {
    fn from(item: Close) -> Self {
        ChannelWitnessUnion::Close(item)
    }
}
impl ::core::convert::From<ForceClose> for ChannelWitnessUnion {
    fn from(item: ForceClose) -> Self {
        ChannelWitnessUnion::ForceClose(item)
    }
}
impl<'r> ::core::convert::From<FundReader<'r>> for ChannelWitnessUnionReader<'r> {
    fn from(item: FundReader<'r>) -> Self {
        ChannelWitnessUnionReader::Fund(item)
    }
}
impl<'r> ::core::convert::From<AbortReader<'r>> for ChannelWitnessUnionReader<'r> {
    fn from(item: AbortReader<'r>) -> Self {
        ChannelWitnessUnionReader::Abort(item)
    }
}
impl<'r> ::core::convert::From<DisputeReader<'r>> for ChannelWitnessUnionReader<'r> {
    fn from(item: DisputeReader<'r>) -> Self {
        ChannelWitnessUnionReader::Dispute(item)
    }
}
impl<'r> ::core::convert::From<CloseReader<'r>> for ChannelWitnessUnionReader<'r> {
    fn from(item: CloseReader<'r>) -> Self {
        ChannelWitnessUnionReader::Close(item)
    }
}
impl<'r> ::core::convert::From<ForceCloseReader<'r>> for ChannelWitnessUnionReader<'r> {
    fn from(item: ForceCloseReader<'r>) -> Self {
        ChannelWitnessUnionReader::ForceClose(item)
    }
}
impl ChannelWitnessUnion {
    pub const NAME: &'static str = "ChannelWitnessUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            ChannelWitnessUnion::Fund(item) => item.as_bytes(),
            ChannelWitnessUnion::Abort(item) => item.as_bytes(),
            ChannelWitnessUnion::Dispute(item) => item.as_bytes(),
            ChannelWitnessUnion::Close(item) => item.as_bytes(),
            ChannelWitnessUnion::ForceClose(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            ChannelWitnessUnion::Fund(item) => item.as_slice(),
            ChannelWitnessUnion::Abort(item) => item.as_slice(),
            ChannelWitnessUnion::Dispute(item) => item.as_slice(),
            ChannelWitnessUnion::Close(item) => item.as_slice(),
            ChannelWitnessUnion::ForceClose(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            ChannelWitnessUnion::Fund(_) => 0,
            ChannelWitnessUnion::Abort(_) => 1,
            ChannelWitnessUnion::Dispute(_) => 2,
            ChannelWitnessUnion::Close(_) => 3,
            ChannelWitnessUnion::ForceClose(_) => 4,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            ChannelWitnessUnion::Fund(_) => "Fund",
            ChannelWitnessUnion::Abort(_) => "Abort",
            ChannelWitnessUnion::Dispute(_) => "Dispute",
            ChannelWitnessUnion::Close(_) => "Close",
            ChannelWitnessUnion::ForceClose(_) => "ForceClose",
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelWitnessUnionReader<'r> {
        match self {
            ChannelWitnessUnion::Fund(item) => item.as_reader().into(),
            ChannelWitnessUnion::Abort(item) => item.as_reader().into(),
            ChannelWitnessUnion::Dispute(item) => item.as_reader().into(),
            ChannelWitnessUnion::Close(item) => item.as_reader().into(),
            ChannelWitnessUnion::ForceClose(item) => item.as_reader().into(),
        }
    }
}
impl<'r> ChannelWitnessUnionReader<'r> {
    pub const NAME: &'r str = "ChannelWitnessUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            ChannelWitnessUnionReader::Fund(item) => item.as_slice(),
            ChannelWitnessUnionReader::Abort(item) => item.as_slice(),
            ChannelWitnessUnionReader::Dispute(item) => item.as_slice(),
            ChannelWitnessUnionReader::Close(item) => item.as_slice(),
            ChannelWitnessUnionReader::ForceClose(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            ChannelWitnessUnionReader::Fund(_) => 0,
            ChannelWitnessUnionReader::Abort(_) => 1,
            ChannelWitnessUnionReader::Dispute(_) => 2,
            ChannelWitnessUnionReader::Close(_) => 3,
            ChannelWitnessUnionReader::ForceClose(_) => 4,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            ChannelWitnessUnionReader::Fund(_) => "Fund",
            ChannelWitnessUnionReader::Abort(_) => "Abort",
            ChannelWitnessUnionReader::Dispute(_) => "Dispute",
            ChannelWitnessUnionReader::Close(_) => "Close",
            ChannelWitnessUnionReader::ForceClose(_) => "ForceClose",
        }
    }
}
#[derive(Clone)]
pub struct ChannelState(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "balances", self.balances())?;
        write!(f, ", {}: {}", "version", self.version())?;
        write!(f, ", {}: {}", "is_final", self.is_final())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelState {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            97, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0,
            12, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ChannelState::new_unchecked(v.into())
    }
}
impl ChannelState {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn balances(&self) -> Balances {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Balances::new_unchecked(self.0.slice(start..end))
    }
    pub fn version(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn is_final(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Bool::new_unchecked(self.0.slice(start..end))
        } else {
            Bool::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelStateReader<'r> {
        ChannelStateReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelState {
    type Builder = ChannelStateBuilder;
    const NAME: &'static str = "ChannelState";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelState(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelStateReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelStateReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .balances(self.balances())
            .version(self.version())
            .is_final(self.is_final())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelStateReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "balances", self.balances())?;
        write!(f, ", {}: {}", "version", self.version())?;
        write!(f, ", {}: {}", "is_final", self.is_final())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelStateReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn balances(&self) -> BalancesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BalancesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn version(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn is_final(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            BoolReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BoolReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelStateReader<'r> {
    type Entity = ChannelState;
    const NAME: &'static str = "ChannelStateReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelStateReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BalancesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        BoolReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelStateBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) balances: Balances,
    pub(crate) version: Uint64,
    pub(crate) is_final: Bool,
}
impl ChannelStateBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn balances(mut self, v: Balances) -> Self {
        self.balances = v;
        self
    }
    pub fn version(mut self, v: Uint64) -> Self {
        self.version = v;
        self
    }
    pub fn is_final(mut self, v: Bool) -> Self {
        self.is_final = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelStateBuilder {
    type Entity = ChannelState;
    const NAME: &'static str = "ChannelStateBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.balances.as_slice().len()
            + self.version.as_slice().len()
            + self.is_final.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.balances.as_slice().len();
        offsets.push(total_size);
        total_size += self.version.as_slice().len();
        offsets.push(total_size);
        total_size += self.is_final.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.balances.as_slice())?;
        writer.write_all(self.version.as_slice())?;
        writer.write_all(self.is_final.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelState::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelStatus(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "state", self.state())?;
        write!(f, ", {}: {}", "funded", self.funded())?;
        write!(f, ", {}: {}", "disputed", self.disputed())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelStatus {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            123, 0, 0, 0, 16, 0, 0, 0, 113, 0, 0, 0, 118, 0, 0, 0, 97, 0, 0, 0, 20, 0, 0, 0, 52, 0,
            0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 12, 0, 0, 0, 28, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ChannelStatus::new_unchecked(v.into())
    }
}
impl ChannelStatus {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn state(&self) -> ChannelState {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelState::new_unchecked(self.0.slice(start..end))
    }
    pub fn funded(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bool::new_unchecked(self.0.slice(start..end))
    }
    pub fn disputed(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Bool::new_unchecked(self.0.slice(start..end))
        } else {
            Bool::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelStatusReader<'r> {
        ChannelStatusReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelStatus {
    type Builder = ChannelStatusBuilder;
    const NAME: &'static str = "ChannelStatus";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelStatus(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelStatusReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelStatusReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .state(self.state())
            .funded(self.funded())
            .disputed(self.disputed())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelStatusReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelStatusReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelStatusReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelStatusReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "state", self.state())?;
        write!(f, ", {}: {}", "funded", self.funded())?;
        write!(f, ", {}: {}", "disputed", self.disputed())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelStatusReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn state(&self) -> ChannelStateReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelStateReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn funded(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BoolReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn disputed(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BoolReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BoolReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelStatusReader<'r> {
    type Entity = ChannelStatus;
    const NAME: &'static str = "ChannelStatusReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelStatusReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ChannelStateReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BoolReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BoolReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelStatusBuilder {
    pub(crate) state: ChannelState,
    pub(crate) funded: Bool,
    pub(crate) disputed: Bool,
}
impl ChannelStatusBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn state(mut self, v: ChannelState) -> Self {
        self.state = v;
        self
    }
    pub fn funded(mut self, v: Bool) -> Self {
        self.funded = v;
        self
    }
    pub fn disputed(mut self, v: Bool) -> Self {
        self.disputed = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelStatusBuilder {
    type Entity = ChannelStatus;
    const NAME: &'static str = "ChannelStatusBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.state.as_slice().len()
            + self.funded.as_slice().len()
            + self.disputed.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.state.as_slice().len();
        offsets.push(total_size);
        total_size += self.funded.as_slice().len();
        offsets.push(total_size);
        total_size += self.disputed.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.state.as_slice())?;
        writer.write_all(self.funded.as_slice())?;
        writer.write_all(self.disputed.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelStatus::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelToken(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelToken {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelToken {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelToken {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "out_point", self.out_point())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelToken {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,
        ];
        ChannelToken::new_unchecked(v.into())
    }
}
impl ChannelToken {
    pub const TOTAL_SIZE: usize = 36;
    pub const FIELD_SIZES: [usize; 1] = [36];
    pub const FIELD_COUNT: usize = 1;
    pub fn out_point(&self) -> OutPoint {
        OutPoint::new_unchecked(self.0.slice(0..36))
    }
    pub fn as_reader<'r>(&'r self) -> ChannelTokenReader<'r> {
        ChannelTokenReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelToken {
    type Builder = ChannelTokenBuilder;
    const NAME: &'static str = "ChannelToken";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelToken(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelTokenReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelTokenReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().out_point(self.out_point())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelTokenReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelTokenReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelTokenReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelTokenReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "out_point", self.out_point())?;
        write!(f, " }}")
    }
}
impl<'r> ChannelTokenReader<'r> {
    pub const TOTAL_SIZE: usize = 36;
    pub const FIELD_SIZES: [usize; 1] = [36];
    pub const FIELD_COUNT: usize = 1;
    pub fn out_point(&self) -> OutPointReader<'r> {
        OutPointReader::new_unchecked(&self.as_slice()[0..36])
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelTokenReader<'r> {
    type Entity = ChannelToken;
    const NAME: &'static str = "ChannelTokenReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelTokenReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelTokenBuilder {
    pub(crate) out_point: OutPoint,
}
impl ChannelTokenBuilder {
    pub const TOTAL_SIZE: usize = 36;
    pub const FIELD_SIZES: [usize; 1] = [36];
    pub const FIELD_COUNT: usize = 1;
    pub fn out_point(mut self, v: OutPoint) -> Self {
        self.out_point = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelTokenBuilder {
    type Entity = ChannelToken;
    const NAME: &'static str = "ChannelTokenBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.out_point.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelToken::new_unchecked(inner.into())
    }
}
