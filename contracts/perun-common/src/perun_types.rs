// Generated by Molecule 0.7.3

#![allow(unused_imports)]
use ckb_types::packed::*;
use ckb_types::prelude::*;
use molecule::prelude::*;

#[derive(Clone)]
pub struct PubKey(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for PubKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for PubKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for PubKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for PubKey {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ];
        PubKey::new_unchecked(v.into())
    }
}
impl PubKey {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> PubKeyReader<'r> {
        PubKeyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for PubKey {
    type Builder = PubKeyBuilder;
    const NAME: &'static str = "PubKey";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        PubKey(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PubKeyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        PubKeyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct PubKeyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for PubKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for PubKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for PubKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> PubKeyReader<'r> {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for PubKeyReader<'r> {
    type Entity = PubKey;
    const NAME: &'static str = "PubKeyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        PubKeyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct PubKeyBuilder(pub(crate) [Byte; 32]);
impl ::core::fmt::Debug for PubKeyBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for PubKeyBuilder {
    fn default() -> Self {
        PubKeyBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl PubKeyBuilder {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 32;
    pub fn set(mut self, v: [Byte; 32]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
}
impl molecule::prelude::Builder for PubKeyBuilder {
    type Entity = PubKey;
    const NAME: &'static str = "PubKeyBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        PubKey::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Balances(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Balances {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Balances {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Balances {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl ::core::default::Default for Balances {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ];
        Balances::new_unchecked(v.into())
    }
}
impl Balances {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 16;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Uint128 {
        Uint128::new_unchecked(self.0.slice(0..16))
    }
    pub fn nth1(&self) -> Uint128 {
        Uint128::new_unchecked(self.0.slice(16..32))
    }
    pub fn as_reader<'r>(&'r self) -> BalancesReader<'r> {
        BalancesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Balances {
    type Builder = BalancesBuilder;
    const NAME: &'static str = "Balances";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Balances(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BalancesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BalancesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1()])
    }
}
#[derive(Clone, Copy)]
pub struct BalancesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BalancesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BalancesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BalancesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        write!(f, "{}", self.nth0())?;
        write!(f, ", {}", self.nth1())?;
        write!(f, "]")
    }
}
impl<'r> BalancesReader<'r> {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 16;
    pub const ITEM_COUNT: usize = 2;
    pub fn nth0(&self) -> Uint128Reader<'r> {
        Uint128Reader::new_unchecked(&self.as_slice()[0..16])
    }
    pub fn nth1(&self) -> Uint128Reader<'r> {
        Uint128Reader::new_unchecked(&self.as_slice()[16..32])
    }
}
impl<'r> molecule::prelude::Reader<'r> for BalancesReader<'r> {
    type Entity = Balances;
    const NAME: &'static str = "BalancesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BalancesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BalancesBuilder(pub(crate) [Uint128; 2]);
impl ::core::fmt::Debug for BalancesBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BalancesBuilder {
    fn default() -> Self {
        BalancesBuilder([Uint128::default(), Uint128::default()])
    }
}
impl BalancesBuilder {
    pub const TOTAL_SIZE: usize = 32;
    pub const ITEM_SIZE: usize = 16;
    pub const ITEM_COUNT: usize = 2;
    pub fn set(mut self, v: [Uint128; 2]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Uint128) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Uint128) -> Self {
        self.0[1] = v;
        self
    }
}
impl molecule::prelude::Builder for BalancesBuilder {
    type Entity = Balances;
    const NAME: &'static str = "BalancesBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Balances::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct True(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for True {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for True {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for True {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for True {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        True::new_unchecked(v.into())
    }
}
impl True {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> TrueReader<'r> {
        TrueReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for True {
    type Builder = TrueBuilder;
    const NAME: &'static str = "True";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        True(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TrueReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TrueReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct TrueReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TrueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TrueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TrueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> TrueReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for TrueReader<'r> {
    type Entity = True;
    const NAME: &'static str = "TrueReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TrueReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct TrueBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for TrueBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for TrueBuilder {
    fn default() -> Self {
        TrueBuilder([Byte::default()])
    }
}
impl TrueBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for TrueBuilder {
    type Entity = True;
    const NAME: &'static str = "TrueBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        True::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct False(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for False {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for False {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for False {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for False {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        False::new_unchecked(v.into())
    }
}
impl False {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> FalseReader<'r> {
        FalseReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for False {
    type Builder = FalseBuilder;
    const NAME: &'static str = "False";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        False(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FalseReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FalseReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct FalseReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FalseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FalseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FalseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> FalseReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for FalseReader<'r> {
    type Entity = False;
    const NAME: &'static str = "FalseReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FalseReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct FalseBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for FalseBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for FalseBuilder {
    fn default() -> Self {
        FalseBuilder([Byte::default()])
    }
}
impl FalseBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for FalseBuilder {
    type Entity = False;
    const NAME: &'static str = "FalseBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        False::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Bool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for Bool {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0];
        Bool::new_unchecked(v.into())
    }
}
impl Bool {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BoolUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => True::new_unchecked(inner).into(),
            1 => False::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> BoolReader<'r> {
        BoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Bool {
    type Builder = BoolBuilder;
    const NAME: &'static str = "Bool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct BoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> BoolReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BoolUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => TrueReader::new_unchecked(inner).into(),
            1 => FalseReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BoolReader<'r> {
    type Entity = Bool;
    const NAME: &'static str = "BoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => TrueReader::verify(inner_slice, compatible),
            1 => FalseReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BoolBuilder(pub(crate) BoolUnion);
impl BoolBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<BoolUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for BoolBuilder {
    type Entity = Bool;
    const NAME: &'static str = "BoolBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Bool::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum BoolUnion {
    True(True),
    False(False),
}
#[derive(Debug, Clone, Copy)]
pub enum BoolUnionReader<'r> {
    True(TrueReader<'r>),
    False(FalseReader<'r>),
}
impl ::core::default::Default for BoolUnion {
    fn default() -> Self {
        BoolUnion::True(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for BoolUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BoolUnion::True(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, True::NAME, item)
            }
            BoolUnion::False(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, False::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for BoolUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BoolUnionReader::True(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, True::NAME, item)
            }
            BoolUnionReader::False(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, False::NAME, item)
            }
        }
    }
}
impl BoolUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BoolUnion::True(ref item) => write!(f, "{}", item),
            BoolUnion::False(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> BoolUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BoolUnionReader::True(ref item) => write!(f, "{}", item),
            BoolUnionReader::False(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<True> for BoolUnion {
    fn from(item: True) -> Self {
        BoolUnion::True(item)
    }
}
impl ::core::convert::From<False> for BoolUnion {
    fn from(item: False) -> Self {
        BoolUnion::False(item)
    }
}
impl<'r> ::core::convert::From<TrueReader<'r>> for BoolUnionReader<'r> {
    fn from(item: TrueReader<'r>) -> Self {
        BoolUnionReader::True(item)
    }
}
impl<'r> ::core::convert::From<FalseReader<'r>> for BoolUnionReader<'r> {
    fn from(item: FalseReader<'r>) -> Self {
        BoolUnionReader::False(item)
    }
}
impl BoolUnion {
    pub const NAME: &'static str = "BoolUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            BoolUnion::True(item) => item.as_bytes(),
            BoolUnion::False(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            BoolUnion::True(item) => item.as_slice(),
            BoolUnion::False(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BoolUnion::True(_) => 0,
            BoolUnion::False(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BoolUnion::True(_) => "True",
            BoolUnion::False(_) => "False",
        }
    }
    pub fn as_reader<'r>(&'r self) -> BoolUnionReader<'r> {
        match self {
            BoolUnion::True(item) => item.as_reader().into(),
            BoolUnion::False(item) => item.as_reader().into(),
        }
    }
}
impl<'r> BoolUnionReader<'r> {
    pub const NAME: &'r str = "BoolUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            BoolUnionReader::True(item) => item.as_slice(),
            BoolUnionReader::False(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BoolUnionReader::True(_) => 0,
            BoolUnionReader::False(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BoolUnionReader::True(_) => "True",
            BoolUnionReader::False(_) => "False",
        }
    }
}
#[derive(Clone)]
pub struct A(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for A {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for A {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for A {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for A {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        A::new_unchecked(v.into())
    }
}
impl A {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> AReader<'r> {
        AReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for A {
    type Builder = ABuilder;
    const NAME: &'static str = "A";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        A(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct AReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> AReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for AReader<'r> {
    type Entity = A;
    const NAME: &'static str = "AReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct ABuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for ABuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for ABuilder {
    fn default() -> Self {
        ABuilder([Byte::default()])
    }
}
impl ABuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for ABuilder {
    type Entity = A;
    const NAME: &'static str = "ABuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        A::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct B(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for B {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for B {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for B {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for B {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        B::new_unchecked(v.into())
    }
}
impl B {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> BReader<'r> {
        BReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for B {
    type Builder = BBuilder;
    const NAME: &'static str = "B";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        B(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct BReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for BReader<'r> {
    type Entity = B;
    const NAME: &'static str = "BReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for BBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BBuilder {
    fn default() -> Self {
        BBuilder([Byte::default()])
    }
}
impl BBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for BBuilder {
    type Entity = B;
    const NAME: &'static str = "BBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        B::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ParticipantIndex(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ParticipantIndex {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ParticipantIndex {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ParticipantIndex {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for ParticipantIndex {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0];
        ParticipantIndex::new_unchecked(v.into())
    }
}
impl ParticipantIndex {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> ParticipantIndexUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => A::new_unchecked(inner).into(),
            1 => B::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> ParticipantIndexReader<'r> {
        ParticipantIndexReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ParticipantIndex {
    type Builder = ParticipantIndexBuilder;
    const NAME: &'static str = "ParticipantIndex";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ParticipantIndex(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ParticipantIndexReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ParticipantIndexReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct ParticipantIndexReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ParticipantIndexReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ParticipantIndexReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ParticipantIndexReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> ParticipantIndexReader<'r> {
    pub const ITEMS_COUNT: usize = 2;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> ParticipantIndexUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => AReader::new_unchecked(inner).into(),
            1 => BReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ParticipantIndexReader<'r> {
    type Entity = ParticipantIndex;
    const NAME: &'static str = "ParticipantIndexReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ParticipantIndexReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => AReader::verify(inner_slice, compatible),
            1 => BReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ParticipantIndexBuilder(pub(crate) ParticipantIndexUnion);
impl ParticipantIndexBuilder {
    pub const ITEMS_COUNT: usize = 2;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<ParticipantIndexUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for ParticipantIndexBuilder {
    type Entity = ParticipantIndex;
    const NAME: &'static str = "ParticipantIndexBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ParticipantIndex::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum ParticipantIndexUnion {
    A(A),
    B(B),
}
#[derive(Debug, Clone, Copy)]
pub enum ParticipantIndexUnionReader<'r> {
    A(AReader<'r>),
    B(BReader<'r>),
}
impl ::core::default::Default for ParticipantIndexUnion {
    fn default() -> Self {
        ParticipantIndexUnion::A(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for ParticipantIndexUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ParticipantIndexUnion::A(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, A::NAME, item)
            }
            ParticipantIndexUnion::B(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, B::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for ParticipantIndexUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ParticipantIndexUnionReader::A(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, A::NAME, item)
            }
            ParticipantIndexUnionReader::B(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, B::NAME, item)
            }
        }
    }
}
impl ParticipantIndexUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ParticipantIndexUnion::A(ref item) => write!(f, "{}", item),
            ParticipantIndexUnion::B(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> ParticipantIndexUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ParticipantIndexUnionReader::A(ref item) => write!(f, "{}", item),
            ParticipantIndexUnionReader::B(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<A> for ParticipantIndexUnion {
    fn from(item: A) -> Self {
        ParticipantIndexUnion::A(item)
    }
}
impl ::core::convert::From<B> for ParticipantIndexUnion {
    fn from(item: B) -> Self {
        ParticipantIndexUnion::B(item)
    }
}
impl<'r> ::core::convert::From<AReader<'r>> for ParticipantIndexUnionReader<'r> {
    fn from(item: AReader<'r>) -> Self {
        ParticipantIndexUnionReader::A(item)
    }
}
impl<'r> ::core::convert::From<BReader<'r>> for ParticipantIndexUnionReader<'r> {
    fn from(item: BReader<'r>) -> Self {
        ParticipantIndexUnionReader::B(item)
    }
}
impl ParticipantIndexUnion {
    pub const NAME: &'static str = "ParticipantIndexUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            ParticipantIndexUnion::A(item) => item.as_bytes(),
            ParticipantIndexUnion::B(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            ParticipantIndexUnion::A(item) => item.as_slice(),
            ParticipantIndexUnion::B(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            ParticipantIndexUnion::A(_) => 0,
            ParticipantIndexUnion::B(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            ParticipantIndexUnion::A(_) => "A",
            ParticipantIndexUnion::B(_) => "B",
        }
    }
    pub fn as_reader<'r>(&'r self) -> ParticipantIndexUnionReader<'r> {
        match self {
            ParticipantIndexUnion::A(item) => item.as_reader().into(),
            ParticipantIndexUnion::B(item) => item.as_reader().into(),
        }
    }
}
impl<'r> ParticipantIndexUnionReader<'r> {
    pub const NAME: &'r str = "ParticipantIndexUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            ParticipantIndexUnionReader::A(item) => item.as_slice(),
            ParticipantIndexUnionReader::B(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            ParticipantIndexUnionReader::A(_) => 0,
            ParticipantIndexUnionReader::B(_) => 1,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            ParticipantIndexUnionReader::A(_) => "A",
            ParticipantIndexUnionReader::B(_) => "B",
        }
    }
}
#[derive(Clone)]
pub struct App(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for App {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for App {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for App {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for App {
    fn default() -> Self {
        let v: Vec<u8> = vec![];
        App::new_unchecked(v.into())
    }
}
impl App {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Bytes> {
        if self.is_none() {
            None
        } else {
            Some(Bytes::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AppReader<'r> {
        AppReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for App {
    type Builder = AppBuilder;
    const NAME: &'static str = "App";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        App(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AppReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AppReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct AppReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AppReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AppReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AppReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> AppReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<BytesReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(BytesReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AppReader<'r> {
    type Entity = App;
    const NAME: &'static str = "AppReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AppReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            BytesReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct AppBuilder(pub(crate) Option<Bytes>);
impl AppBuilder {
    pub fn set(mut self, v: Option<Bytes>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for AppBuilder {
    type Entity = App;
    const NAME: &'static str = "AppBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        App::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Participant(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Participant {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Participant {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Participant {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "unlock_args", self.unlock_args())?;
        write!(f, ", {}: {}", "payment_args", self.payment_args())?;
        write!(f, ", {}: {}", "pub_key", self.pub_key())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Participant {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            56, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        Participant::new_unchecked(v.into())
    }
}
impl Participant {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn unlock_args(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn payment_args(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn pub_key(&self) -> PubKey {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            PubKey::new_unchecked(self.0.slice(start..end))
        } else {
            PubKey::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ParticipantReader<'r> {
        ParticipantReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Participant {
    type Builder = ParticipantBuilder;
    const NAME: &'static str = "Participant";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Participant(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ParticipantReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ParticipantReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .unlock_args(self.unlock_args())
            .payment_args(self.payment_args())
            .pub_key(self.pub_key())
    }
}
#[derive(Clone, Copy)]
pub struct ParticipantReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ParticipantReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ParticipantReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ParticipantReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "unlock_args", self.unlock_args())?;
        write!(f, ", {}: {}", "payment_args", self.payment_args())?;
        write!(f, ", {}: {}", "pub_key", self.pub_key())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ParticipantReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn unlock_args(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn payment_args(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pub_key(&self) -> PubKeyReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            PubKeyReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            PubKeyReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ParticipantReader<'r> {
    type Entity = Participant;
    const NAME: &'static str = "ParticipantReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ParticipantReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        PubKeyReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ParticipantBuilder {
    pub(crate) unlock_args: Bytes,
    pub(crate) payment_args: Bytes,
    pub(crate) pub_key: PubKey,
}
impl ParticipantBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn unlock_args(mut self, v: Bytes) -> Self {
        self.unlock_args = v;
        self
    }
    pub fn payment_args(mut self, v: Bytes) -> Self {
        self.payment_args = v;
        self
    }
    pub fn pub_key(mut self, v: PubKey) -> Self {
        self.pub_key = v;
        self
    }
}
impl molecule::prelude::Builder for ParticipantBuilder {
    type Entity = Participant;
    const NAME: &'static str = "ParticipantBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.unlock_args.as_slice().len()
            + self.payment_args.as_slice().len()
            + self.pub_key.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.unlock_args.as_slice().len();
        offsets.push(total_size);
        total_size += self.payment_args.as_slice().len();
        offsets.push(total_size);
        total_size += self.pub_key.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.unlock_args.as_slice())?;
        writer.write_all(self.payment_args.as_slice())?;
        writer.write_all(self.pub_key.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Participant::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelParameters(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelParameters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelParameters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelParameters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "party_a", self.party_a())?;
        write!(f, ", {}: {}", "party_b", self.party_b())?;
        write!(f, ", {}: {}", "nonce", self.nonce())?;
        write!(
            f,
            ", {}: {}",
            "challenge_duration",
            self.challenge_duration()
        )?;
        write!(f, ", {}: {}", "app", self.app())?;
        write!(f, ", {}: {}", "is_ledger_channel", self.is_ledger_channel())?;
        write!(
            f,
            ", {}: {}",
            "is_virtual_channel",
            self.is_virtual_channel()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelParameters {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            194, 0, 0, 0, 32, 0, 0, 0, 88, 0, 0, 0, 144, 0, 0, 0, 176, 0, 0, 0, 184, 0, 0, 0, 184,
            0, 0, 0, 189, 0, 0, 0, 56, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ChannelParameters::new_unchecked(v.into())
    }
}
impl ChannelParameters {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn party_a(&self) -> Participant {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Participant::new_unchecked(self.0.slice(start..end))
    }
    pub fn party_b(&self) -> Participant {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Participant::new_unchecked(self.0.slice(start..end))
    }
    pub fn nonce(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn challenge_duration(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn app(&self) -> App {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        App::new_unchecked(self.0.slice(start..end))
    }
    pub fn is_ledger_channel(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Bool::new_unchecked(self.0.slice(start..end))
    }
    pub fn is_virtual_channel(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            Bool::new_unchecked(self.0.slice(start..end))
        } else {
            Bool::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelParametersReader<'r> {
        ChannelParametersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelParameters {
    type Builder = ChannelParametersBuilder;
    const NAME: &'static str = "ChannelParameters";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelParameters(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelParametersReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelParametersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .party_a(self.party_a())
            .party_b(self.party_b())
            .nonce(self.nonce())
            .challenge_duration(self.challenge_duration())
            .app(self.app())
            .is_ledger_channel(self.is_ledger_channel())
            .is_virtual_channel(self.is_virtual_channel())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelParametersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelParametersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelParametersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelParametersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "party_a", self.party_a())?;
        write!(f, ", {}: {}", "party_b", self.party_b())?;
        write!(f, ", {}: {}", "nonce", self.nonce())?;
        write!(
            f,
            ", {}: {}",
            "challenge_duration",
            self.challenge_duration()
        )?;
        write!(f, ", {}: {}", "app", self.app())?;
        write!(f, ", {}: {}", "is_ledger_channel", self.is_ledger_channel())?;
        write!(
            f,
            ", {}: {}",
            "is_virtual_channel",
            self.is_virtual_channel()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelParametersReader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn party_a(&self) -> ParticipantReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ParticipantReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn party_b(&self) -> ParticipantReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ParticipantReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn nonce(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn challenge_duration(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn app(&self) -> AppReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        AppReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn is_ledger_channel(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BoolReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn is_virtual_channel(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            BoolReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BoolReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelParametersReader<'r> {
    type Entity = ChannelParameters;
    const NAME: &'static str = "ChannelParametersReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelParametersReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ParticipantReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ParticipantReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        AppReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BoolReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        BoolReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelParametersBuilder {
    pub(crate) party_a: Participant,
    pub(crate) party_b: Participant,
    pub(crate) nonce: Byte32,
    pub(crate) challenge_duration: Uint64,
    pub(crate) app: App,
    pub(crate) is_ledger_channel: Bool,
    pub(crate) is_virtual_channel: Bool,
}
impl ChannelParametersBuilder {
    pub const FIELD_COUNT: usize = 7;
    pub fn party_a(mut self, v: Participant) -> Self {
        self.party_a = v;
        self
    }
    pub fn party_b(mut self, v: Participant) -> Self {
        self.party_b = v;
        self
    }
    pub fn nonce(mut self, v: Byte32) -> Self {
        self.nonce = v;
        self
    }
    pub fn challenge_duration(mut self, v: Uint64) -> Self {
        self.challenge_duration = v;
        self
    }
    pub fn app(mut self, v: App) -> Self {
        self.app = v;
        self
    }
    pub fn is_ledger_channel(mut self, v: Bool) -> Self {
        self.is_ledger_channel = v;
        self
    }
    pub fn is_virtual_channel(mut self, v: Bool) -> Self {
        self.is_virtual_channel = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelParametersBuilder {
    type Entity = ChannelParameters;
    const NAME: &'static str = "ChannelParametersBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.party_a.as_slice().len()
            + self.party_b.as_slice().len()
            + self.nonce.as_slice().len()
            + self.challenge_duration.as_slice().len()
            + self.app.as_slice().len()
            + self.is_ledger_channel.as_slice().len()
            + self.is_virtual_channel.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.party_a.as_slice().len();
        offsets.push(total_size);
        total_size += self.party_b.as_slice().len();
        offsets.push(total_size);
        total_size += self.nonce.as_slice().len();
        offsets.push(total_size);
        total_size += self.challenge_duration.as_slice().len();
        offsets.push(total_size);
        total_size += self.app.as_slice().len();
        offsets.push(total_size);
        total_size += self.is_ledger_channel.as_slice().len();
        offsets.push(total_size);
        total_size += self.is_virtual_channel.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.party_a.as_slice())?;
        writer.write_all(self.party_b.as_slice())?;
        writer.write_all(self.nonce.as_slice())?;
        writer.write_all(self.challenge_duration.as_slice())?;
        writer.write_all(self.app.as_slice())?;
        writer.write_all(self.is_ledger_channel.as_slice())?;
        writer.write_all(self.is_virtual_channel.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelParameters::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelConstants(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "params", self.params())?;
        write!(f, ", {}: {}", "pfls_hash", self.pfls_hash())?;
        write!(f, ", {}: {}", "pcls_hash", self.pcls_hash())?;
        write!(
            f,
            ", {}: {}",
            "pcls_unlock_script_hash",
            self.pcls_unlock_script_hash()
        )?;
        write!(f, ", {}: {}", "payment_lock_hash", self.payment_lock_hash())?;
        write!(f, ", {}: {}", "pfls_args", self.pfls_args())?;
        write!(f, ", {}: {}", "thread_token", self.thread_token())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelConstants {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            138, 1, 0, 0, 32, 0, 0, 0, 226, 0, 0, 0, 2, 1, 0, 0, 34, 1, 0, 0, 66, 1, 0, 0, 98, 1,
            0, 0, 102, 1, 0, 0, 194, 0, 0, 0, 32, 0, 0, 0, 88, 0, 0, 0, 144, 0, 0, 0, 176, 0, 0, 0,
            184, 0, 0, 0, 184, 0, 0, 0, 189, 0, 0, 0, 56, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ChannelConstants::new_unchecked(v.into())
    }
}
impl ChannelConstants {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn params(&self) -> ChannelParameters {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelParameters::new_unchecked(self.0.slice(start..end))
    }
    pub fn pfls_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn pcls_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn pcls_unlock_script_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn payment_lock_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn pfls_args(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn thread_token(&self) -> ChannelToken {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            ChannelToken::new_unchecked(self.0.slice(start..end))
        } else {
            ChannelToken::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelConstantsReader<'r> {
        ChannelConstantsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelConstants {
    type Builder = ChannelConstantsBuilder;
    const NAME: &'static str = "ChannelConstants";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelConstants(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelConstantsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelConstantsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .params(self.params())
            .pfls_hash(self.pfls_hash())
            .pcls_hash(self.pcls_hash())
            .pcls_unlock_script_hash(self.pcls_unlock_script_hash())
            .payment_lock_hash(self.payment_lock_hash())
            .pfls_args(self.pfls_args())
            .thread_token(self.thread_token())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelConstantsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelConstantsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelConstantsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelConstantsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "params", self.params())?;
        write!(f, ", {}: {}", "pfls_hash", self.pfls_hash())?;
        write!(f, ", {}: {}", "pcls_hash", self.pcls_hash())?;
        write!(
            f,
            ", {}: {}",
            "pcls_unlock_script_hash",
            self.pcls_unlock_script_hash()
        )?;
        write!(f, ", {}: {}", "payment_lock_hash", self.payment_lock_hash())?;
        write!(f, ", {}: {}", "pfls_args", self.pfls_args())?;
        write!(f, ", {}: {}", "thread_token", self.thread_token())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelConstantsReader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn params(&self) -> ChannelParametersReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelParametersReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pfls_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pcls_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pcls_unlock_script_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn payment_lock_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn pfls_args(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn thread_token(&self) -> ChannelTokenReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            ChannelTokenReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ChannelTokenReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelConstantsReader<'r> {
    type Entity = ChannelConstants;
    const NAME: &'static str = "ChannelConstantsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelConstantsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ChannelParametersReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Byte32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BytesReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        ChannelTokenReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelConstantsBuilder {
    pub(crate) params: ChannelParameters,
    pub(crate) pfls_hash: Byte32,
    pub(crate) pcls_hash: Byte32,
    pub(crate) pcls_unlock_script_hash: Byte32,
    pub(crate) payment_lock_hash: Byte32,
    pub(crate) pfls_args: Bytes,
    pub(crate) thread_token: ChannelToken,
}
impl ChannelConstantsBuilder {
    pub const FIELD_COUNT: usize = 7;
    pub fn params(mut self, v: ChannelParameters) -> Self {
        self.params = v;
        self
    }
    pub fn pfls_hash(mut self, v: Byte32) -> Self {
        self.pfls_hash = v;
        self
    }
    pub fn pcls_hash(mut self, v: Byte32) -> Self {
        self.pcls_hash = v;
        self
    }
    pub fn pcls_unlock_script_hash(mut self, v: Byte32) -> Self {
        self.pcls_unlock_script_hash = v;
        self
    }
    pub fn payment_lock_hash(mut self, v: Byte32) -> Self {
        self.payment_lock_hash = v;
        self
    }
    pub fn pfls_args(mut self, v: Bytes) -> Self {
        self.pfls_args = v;
        self
    }
    pub fn thread_token(mut self, v: ChannelToken) -> Self {
        self.thread_token = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelConstantsBuilder {
    type Entity = ChannelConstants;
    const NAME: &'static str = "ChannelConstantsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.params.as_slice().len()
            + self.pfls_hash.as_slice().len()
            + self.pcls_hash.as_slice().len()
            + self.pcls_unlock_script_hash.as_slice().len()
            + self.payment_lock_hash.as_slice().len()
            + self.pfls_args.as_slice().len()
            + self.thread_token.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.params.as_slice().len();
        offsets.push(total_size);
        total_size += self.pfls_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.pcls_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.pcls_unlock_script_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.payment_lock_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.pfls_args.as_slice().len();
        offsets.push(total_size);
        total_size += self.thread_token.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.params.as_slice())?;
        writer.write_all(self.pfls_hash.as_slice())?;
        writer.write_all(self.pcls_hash.as_slice())?;
        writer.write_all(self.pcls_unlock_script_hash.as_slice())?;
        writer.write_all(self.payment_lock_hash.as_slice())?;
        writer.write_all(self.pfls_args.as_slice())?;
        writer.write_all(self.thread_token.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelConstants::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Signature(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Signature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Signature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Signature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Signature {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,
        ];
        Signature::new_unchecked(v.into())
    }
}
impl Signature {
    pub const TOTAL_SIZE: usize = 65;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 65;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn nth8(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(8..9))
    }
    pub fn nth9(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(9..10))
    }
    pub fn nth10(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(10..11))
    }
    pub fn nth11(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(11..12))
    }
    pub fn nth12(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(12..13))
    }
    pub fn nth13(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(13..14))
    }
    pub fn nth14(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(14..15))
    }
    pub fn nth15(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(15..16))
    }
    pub fn nth16(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(16..17))
    }
    pub fn nth17(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(17..18))
    }
    pub fn nth18(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(18..19))
    }
    pub fn nth19(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(19..20))
    }
    pub fn nth20(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(20..21))
    }
    pub fn nth21(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(21..22))
    }
    pub fn nth22(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(22..23))
    }
    pub fn nth23(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(23..24))
    }
    pub fn nth24(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(24..25))
    }
    pub fn nth25(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(25..26))
    }
    pub fn nth26(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(26..27))
    }
    pub fn nth27(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(27..28))
    }
    pub fn nth28(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(28..29))
    }
    pub fn nth29(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(29..30))
    }
    pub fn nth30(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(30..31))
    }
    pub fn nth31(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(31..32))
    }
    pub fn nth32(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(32..33))
    }
    pub fn nth33(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(33..34))
    }
    pub fn nth34(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(34..35))
    }
    pub fn nth35(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(35..36))
    }
    pub fn nth36(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(36..37))
    }
    pub fn nth37(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(37..38))
    }
    pub fn nth38(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(38..39))
    }
    pub fn nth39(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(39..40))
    }
    pub fn nth40(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(40..41))
    }
    pub fn nth41(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(41..42))
    }
    pub fn nth42(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(42..43))
    }
    pub fn nth43(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(43..44))
    }
    pub fn nth44(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(44..45))
    }
    pub fn nth45(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(45..46))
    }
    pub fn nth46(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(46..47))
    }
    pub fn nth47(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(47..48))
    }
    pub fn nth48(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(48..49))
    }
    pub fn nth49(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(49..50))
    }
    pub fn nth50(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(50..51))
    }
    pub fn nth51(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(51..52))
    }
    pub fn nth52(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(52..53))
    }
    pub fn nth53(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(53..54))
    }
    pub fn nth54(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(54..55))
    }
    pub fn nth55(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(55..56))
    }
    pub fn nth56(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(56..57))
    }
    pub fn nth57(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(57..58))
    }
    pub fn nth58(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(58..59))
    }
    pub fn nth59(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(59..60))
    }
    pub fn nth60(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(60..61))
    }
    pub fn nth61(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(61..62))
    }
    pub fn nth62(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(62..63))
    }
    pub fn nth63(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(63..64))
    }
    pub fn nth64(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(64..65))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> SignatureReader<'r> {
        SignatureReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Signature {
    type Builder = SignatureBuilder;
    const NAME: &'static str = "Signature";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Signature(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SignatureReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SignatureReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
            self.nth8(),
            self.nth9(),
            self.nth10(),
            self.nth11(),
            self.nth12(),
            self.nth13(),
            self.nth14(),
            self.nth15(),
            self.nth16(),
            self.nth17(),
            self.nth18(),
            self.nth19(),
            self.nth20(),
            self.nth21(),
            self.nth22(),
            self.nth23(),
            self.nth24(),
            self.nth25(),
            self.nth26(),
            self.nth27(),
            self.nth28(),
            self.nth29(),
            self.nth30(),
            self.nth31(),
            self.nth32(),
            self.nth33(),
            self.nth34(),
            self.nth35(),
            self.nth36(),
            self.nth37(),
            self.nth38(),
            self.nth39(),
            self.nth40(),
            self.nth41(),
            self.nth42(),
            self.nth43(),
            self.nth44(),
            self.nth45(),
            self.nth46(),
            self.nth47(),
            self.nth48(),
            self.nth49(),
            self.nth50(),
            self.nth51(),
            self.nth52(),
            self.nth53(),
            self.nth54(),
            self.nth55(),
            self.nth56(),
            self.nth57(),
            self.nth58(),
            self.nth59(),
            self.nth60(),
            self.nth61(),
            self.nth62(),
            self.nth63(),
            self.nth64(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct SignatureReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SignatureReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SignatureReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SignatureReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> SignatureReader<'r> {
    pub const TOTAL_SIZE: usize = 65;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 65;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn nth8(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[8..9])
    }
    pub fn nth9(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[9..10])
    }
    pub fn nth10(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[10..11])
    }
    pub fn nth11(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[11..12])
    }
    pub fn nth12(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[12..13])
    }
    pub fn nth13(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[13..14])
    }
    pub fn nth14(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[14..15])
    }
    pub fn nth15(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[15..16])
    }
    pub fn nth16(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[16..17])
    }
    pub fn nth17(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[17..18])
    }
    pub fn nth18(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[18..19])
    }
    pub fn nth19(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[19..20])
    }
    pub fn nth20(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[20..21])
    }
    pub fn nth21(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[21..22])
    }
    pub fn nth22(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[22..23])
    }
    pub fn nth23(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[23..24])
    }
    pub fn nth24(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[24..25])
    }
    pub fn nth25(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[25..26])
    }
    pub fn nth26(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[26..27])
    }
    pub fn nth27(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[27..28])
    }
    pub fn nth28(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[28..29])
    }
    pub fn nth29(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[29..30])
    }
    pub fn nth30(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[30..31])
    }
    pub fn nth31(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[31..32])
    }
    pub fn nth32(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[32..33])
    }
    pub fn nth33(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[33..34])
    }
    pub fn nth34(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[34..35])
    }
    pub fn nth35(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[35..36])
    }
    pub fn nth36(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[36..37])
    }
    pub fn nth37(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[37..38])
    }
    pub fn nth38(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[38..39])
    }
    pub fn nth39(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[39..40])
    }
    pub fn nth40(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[40..41])
    }
    pub fn nth41(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[41..42])
    }
    pub fn nth42(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[42..43])
    }
    pub fn nth43(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[43..44])
    }
    pub fn nth44(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[44..45])
    }
    pub fn nth45(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[45..46])
    }
    pub fn nth46(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[46..47])
    }
    pub fn nth47(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[47..48])
    }
    pub fn nth48(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[48..49])
    }
    pub fn nth49(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[49..50])
    }
    pub fn nth50(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[50..51])
    }
    pub fn nth51(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[51..52])
    }
    pub fn nth52(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[52..53])
    }
    pub fn nth53(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[53..54])
    }
    pub fn nth54(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[54..55])
    }
    pub fn nth55(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[55..56])
    }
    pub fn nth56(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[56..57])
    }
    pub fn nth57(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[57..58])
    }
    pub fn nth58(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[58..59])
    }
    pub fn nth59(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[59..60])
    }
    pub fn nth60(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[60..61])
    }
    pub fn nth61(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[61..62])
    }
    pub fn nth62(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[62..63])
    }
    pub fn nth63(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[63..64])
    }
    pub fn nth64(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[64..65])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for SignatureReader<'r> {
    type Entity = Signature;
    const NAME: &'static str = "SignatureReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SignatureReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct SignatureBuilder(pub(crate) [Byte; 65]);
impl ::core::fmt::Debug for SignatureBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for SignatureBuilder {
    fn default() -> Self {
        SignatureBuilder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl SignatureBuilder {
    pub const TOTAL_SIZE: usize = 65;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 65;
    pub fn set(mut self, v: [Byte; 65]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
    pub fn nth8(mut self, v: Byte) -> Self {
        self.0[8] = v;
        self
    }
    pub fn nth9(mut self, v: Byte) -> Self {
        self.0[9] = v;
        self
    }
    pub fn nth10(mut self, v: Byte) -> Self {
        self.0[10] = v;
        self
    }
    pub fn nth11(mut self, v: Byte) -> Self {
        self.0[11] = v;
        self
    }
    pub fn nth12(mut self, v: Byte) -> Self {
        self.0[12] = v;
        self
    }
    pub fn nth13(mut self, v: Byte) -> Self {
        self.0[13] = v;
        self
    }
    pub fn nth14(mut self, v: Byte) -> Self {
        self.0[14] = v;
        self
    }
    pub fn nth15(mut self, v: Byte) -> Self {
        self.0[15] = v;
        self
    }
    pub fn nth16(mut self, v: Byte) -> Self {
        self.0[16] = v;
        self
    }
    pub fn nth17(mut self, v: Byte) -> Self {
        self.0[17] = v;
        self
    }
    pub fn nth18(mut self, v: Byte) -> Self {
        self.0[18] = v;
        self
    }
    pub fn nth19(mut self, v: Byte) -> Self {
        self.0[19] = v;
        self
    }
    pub fn nth20(mut self, v: Byte) -> Self {
        self.0[20] = v;
        self
    }
    pub fn nth21(mut self, v: Byte) -> Self {
        self.0[21] = v;
        self
    }
    pub fn nth22(mut self, v: Byte) -> Self {
        self.0[22] = v;
        self
    }
    pub fn nth23(mut self, v: Byte) -> Self {
        self.0[23] = v;
        self
    }
    pub fn nth24(mut self, v: Byte) -> Self {
        self.0[24] = v;
        self
    }
    pub fn nth25(mut self, v: Byte) -> Self {
        self.0[25] = v;
        self
    }
    pub fn nth26(mut self, v: Byte) -> Self {
        self.0[26] = v;
        self
    }
    pub fn nth27(mut self, v: Byte) -> Self {
        self.0[27] = v;
        self
    }
    pub fn nth28(mut self, v: Byte) -> Self {
        self.0[28] = v;
        self
    }
    pub fn nth29(mut self, v: Byte) -> Self {
        self.0[29] = v;
        self
    }
    pub fn nth30(mut self, v: Byte) -> Self {
        self.0[30] = v;
        self
    }
    pub fn nth31(mut self, v: Byte) -> Self {
        self.0[31] = v;
        self
    }
    pub fn nth32(mut self, v: Byte) -> Self {
        self.0[32] = v;
        self
    }
    pub fn nth33(mut self, v: Byte) -> Self {
        self.0[33] = v;
        self
    }
    pub fn nth34(mut self, v: Byte) -> Self {
        self.0[34] = v;
        self
    }
    pub fn nth35(mut self, v: Byte) -> Self {
        self.0[35] = v;
        self
    }
    pub fn nth36(mut self, v: Byte) -> Self {
        self.0[36] = v;
        self
    }
    pub fn nth37(mut self, v: Byte) -> Self {
        self.0[37] = v;
        self
    }
    pub fn nth38(mut self, v: Byte) -> Self {
        self.0[38] = v;
        self
    }
    pub fn nth39(mut self, v: Byte) -> Self {
        self.0[39] = v;
        self
    }
    pub fn nth40(mut self, v: Byte) -> Self {
        self.0[40] = v;
        self
    }
    pub fn nth41(mut self, v: Byte) -> Self {
        self.0[41] = v;
        self
    }
    pub fn nth42(mut self, v: Byte) -> Self {
        self.0[42] = v;
        self
    }
    pub fn nth43(mut self, v: Byte) -> Self {
        self.0[43] = v;
        self
    }
    pub fn nth44(mut self, v: Byte) -> Self {
        self.0[44] = v;
        self
    }
    pub fn nth45(mut self, v: Byte) -> Self {
        self.0[45] = v;
        self
    }
    pub fn nth46(mut self, v: Byte) -> Self {
        self.0[46] = v;
        self
    }
    pub fn nth47(mut self, v: Byte) -> Self {
        self.0[47] = v;
        self
    }
    pub fn nth48(mut self, v: Byte) -> Self {
        self.0[48] = v;
        self
    }
    pub fn nth49(mut self, v: Byte) -> Self {
        self.0[49] = v;
        self
    }
    pub fn nth50(mut self, v: Byte) -> Self {
        self.0[50] = v;
        self
    }
    pub fn nth51(mut self, v: Byte) -> Self {
        self.0[51] = v;
        self
    }
    pub fn nth52(mut self, v: Byte) -> Self {
        self.0[52] = v;
        self
    }
    pub fn nth53(mut self, v: Byte) -> Self {
        self.0[53] = v;
        self
    }
    pub fn nth54(mut self, v: Byte) -> Self {
        self.0[54] = v;
        self
    }
    pub fn nth55(mut self, v: Byte) -> Self {
        self.0[55] = v;
        self
    }
    pub fn nth56(mut self, v: Byte) -> Self {
        self.0[56] = v;
        self
    }
    pub fn nth57(mut self, v: Byte) -> Self {
        self.0[57] = v;
        self
    }
    pub fn nth58(mut self, v: Byte) -> Self {
        self.0[58] = v;
        self
    }
    pub fn nth59(mut self, v: Byte) -> Self {
        self.0[59] = v;
        self
    }
    pub fn nth60(mut self, v: Byte) -> Self {
        self.0[60] = v;
        self
    }
    pub fn nth61(mut self, v: Byte) -> Self {
        self.0[61] = v;
        self
    }
    pub fn nth62(mut self, v: Byte) -> Self {
        self.0[62] = v;
        self
    }
    pub fn nth63(mut self, v: Byte) -> Self {
        self.0[63] = v;
        self
    }
    pub fn nth64(mut self, v: Byte) -> Self {
        self.0[64] = v;
        self
    }
}
impl molecule::prelude::Builder for SignatureBuilder {
    type Entity = Signature;
    const NAME: &'static str = "SignatureBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        writer.write_all(self.0[8].as_slice())?;
        writer.write_all(self.0[9].as_slice())?;
        writer.write_all(self.0[10].as_slice())?;
        writer.write_all(self.0[11].as_slice())?;
        writer.write_all(self.0[12].as_slice())?;
        writer.write_all(self.0[13].as_slice())?;
        writer.write_all(self.0[14].as_slice())?;
        writer.write_all(self.0[15].as_slice())?;
        writer.write_all(self.0[16].as_slice())?;
        writer.write_all(self.0[17].as_slice())?;
        writer.write_all(self.0[18].as_slice())?;
        writer.write_all(self.0[19].as_slice())?;
        writer.write_all(self.0[20].as_slice())?;
        writer.write_all(self.0[21].as_slice())?;
        writer.write_all(self.0[22].as_slice())?;
        writer.write_all(self.0[23].as_slice())?;
        writer.write_all(self.0[24].as_slice())?;
        writer.write_all(self.0[25].as_slice())?;
        writer.write_all(self.0[26].as_slice())?;
        writer.write_all(self.0[27].as_slice())?;
        writer.write_all(self.0[28].as_slice())?;
        writer.write_all(self.0[29].as_slice())?;
        writer.write_all(self.0[30].as_slice())?;
        writer.write_all(self.0[31].as_slice())?;
        writer.write_all(self.0[32].as_slice())?;
        writer.write_all(self.0[33].as_slice())?;
        writer.write_all(self.0[34].as_slice())?;
        writer.write_all(self.0[35].as_slice())?;
        writer.write_all(self.0[36].as_slice())?;
        writer.write_all(self.0[37].as_slice())?;
        writer.write_all(self.0[38].as_slice())?;
        writer.write_all(self.0[39].as_slice())?;
        writer.write_all(self.0[40].as_slice())?;
        writer.write_all(self.0[41].as_slice())?;
        writer.write_all(self.0[42].as_slice())?;
        writer.write_all(self.0[43].as_slice())?;
        writer.write_all(self.0[44].as_slice())?;
        writer.write_all(self.0[45].as_slice())?;
        writer.write_all(self.0[46].as_slice())?;
        writer.write_all(self.0[47].as_slice())?;
        writer.write_all(self.0[48].as_slice())?;
        writer.write_all(self.0[49].as_slice())?;
        writer.write_all(self.0[50].as_slice())?;
        writer.write_all(self.0[51].as_slice())?;
        writer.write_all(self.0[52].as_slice())?;
        writer.write_all(self.0[53].as_slice())?;
        writer.write_all(self.0[54].as_slice())?;
        writer.write_all(self.0[55].as_slice())?;
        writer.write_all(self.0[56].as_slice())?;
        writer.write_all(self.0[57].as_slice())?;
        writer.write_all(self.0[58].as_slice())?;
        writer.write_all(self.0[59].as_slice())?;
        writer.write_all(self.0[60].as_slice())?;
        writer.write_all(self.0[61].as_slice())?;
        writer.write_all(self.0[62].as_slice())?;
        writer.write_all(self.0[63].as_slice())?;
        writer.write_all(self.0[64].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Signature::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Fund(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Fund {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Fund {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Fund {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "index", self.index())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Fund {
    fn default() -> Self {
        let v: Vec<u8> = vec![13, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0];
        Fund::new_unchecked(v.into())
    }
}
impl Fund {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn index(&self) -> ParticipantIndex {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            ParticipantIndex::new_unchecked(self.0.slice(start..end))
        } else {
            ParticipantIndex::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> FundReader<'r> {
        FundReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Fund {
    type Builder = FundBuilder;
    const NAME: &'static str = "Fund";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Fund(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FundReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FundReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().index(self.index())
    }
}
#[derive(Clone, Copy)]
pub struct FundReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FundReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FundReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FundReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "index", self.index())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> FundReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn index(&self) -> ParticipantIndexReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            ParticipantIndexReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ParticipantIndexReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FundReader<'r> {
    type Entity = Fund;
    const NAME: &'static str = "FundReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FundReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ParticipantIndexReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct FundBuilder {
    pub(crate) index: ParticipantIndex,
}
impl FundBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn index(mut self, v: ParticipantIndex) -> Self {
        self.index = v;
        self
    }
}
impl molecule::prelude::Builder for FundBuilder {
    type Entity = Fund;
    const NAME: &'static str = "FundBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.index.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.index.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.index.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Fund::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Abort(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Abort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Abort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Abort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Abort {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        Abort::new_unchecked(v.into())
    }
}
impl Abort {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> AbortReader<'r> {
        AbortReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Abort {
    type Builder = AbortBuilder;
    const NAME: &'static str = "Abort";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Abort(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AbortReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AbortReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct AbortReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AbortReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AbortReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AbortReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> AbortReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for AbortReader<'r> {
    type Entity = Abort;
    const NAME: &'static str = "AbortReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AbortReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct AbortBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for AbortBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for AbortBuilder {
    fn default() -> Self {
        AbortBuilder([Byte::default()])
    }
}
impl AbortBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for AbortBuilder {
    type Entity = Abort;
    const NAME: &'static str = "AbortBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Abort::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Dispute(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Dispute {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Dispute {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Dispute {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "sig_a", self.sig_a())?;
        write!(f, ", {}: {}", "sig_b", self.sig_b())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for Dispute {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        Dispute::new_unchecked(v.into())
    }
}
impl Dispute {
    pub const TOTAL_SIZE: usize = 130;
    pub const FIELD_SIZES: [usize; 2] = [65, 65];
    pub const FIELD_COUNT: usize = 2;
    pub fn sig_a(&self) -> Signature {
        Signature::new_unchecked(self.0.slice(0..65))
    }
    pub fn sig_b(&self) -> Signature {
        Signature::new_unchecked(self.0.slice(65..130))
    }
    pub fn as_reader<'r>(&'r self) -> DisputeReader<'r> {
        DisputeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Dispute {
    type Builder = DisputeBuilder;
    const NAME: &'static str = "Dispute";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Dispute(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DisputeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        DisputeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().sig_a(self.sig_a()).sig_b(self.sig_b())
    }
}
#[derive(Clone, Copy)]
pub struct DisputeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for DisputeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for DisputeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for DisputeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "sig_a", self.sig_a())?;
        write!(f, ", {}: {}", "sig_b", self.sig_b())?;
        write!(f, " }}")
    }
}
impl<'r> DisputeReader<'r> {
    pub const TOTAL_SIZE: usize = 130;
    pub const FIELD_SIZES: [usize; 2] = [65, 65];
    pub const FIELD_COUNT: usize = 2;
    pub fn sig_a(&self) -> SignatureReader<'r> {
        SignatureReader::new_unchecked(&self.as_slice()[0..65])
    }
    pub fn sig_b(&self) -> SignatureReader<'r> {
        SignatureReader::new_unchecked(&self.as_slice()[65..130])
    }
}
impl<'r> molecule::prelude::Reader<'r> for DisputeReader<'r> {
    type Entity = Dispute;
    const NAME: &'static str = "DisputeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        DisputeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct DisputeBuilder {
    pub(crate) sig_a: Signature,
    pub(crate) sig_b: Signature,
}
impl DisputeBuilder {
    pub const TOTAL_SIZE: usize = 130;
    pub const FIELD_SIZES: [usize; 2] = [65, 65];
    pub const FIELD_COUNT: usize = 2;
    pub fn sig_a(mut self, v: Signature) -> Self {
        self.sig_a = v;
        self
    }
    pub fn sig_b(mut self, v: Signature) -> Self {
        self.sig_b = v;
        self
    }
}
impl molecule::prelude::Builder for DisputeBuilder {
    type Entity = Dispute;
    const NAME: &'static str = "DisputeBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.sig_a.as_slice())?;
        writer.write_all(self.sig_b.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Dispute::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Close(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Close {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Close {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Close {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "state", self.state())?;
        write!(f, ", {}: {}", "sig_a", self.sig_a())?;
        write!(f, ", {}: {}", "sig_b", self.sig_b())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Close {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            243, 0, 0, 0, 16, 0, 0, 0, 113, 0, 0, 0, 178, 0, 0, 0, 97, 0, 0, 0, 20, 0, 0, 0, 52, 0,
            0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        Close::new_unchecked(v.into())
    }
}
impl Close {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn state(&self) -> ChannelState {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelState::new_unchecked(self.0.slice(start..end))
    }
    pub fn sig_a(&self) -> Signature {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Signature::new_unchecked(self.0.slice(start..end))
    }
    pub fn sig_b(&self) -> Signature {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Signature::new_unchecked(self.0.slice(start..end))
        } else {
            Signature::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CloseReader<'r> {
        CloseReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Close {
    type Builder = CloseBuilder;
    const NAME: &'static str = "Close";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Close(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CloseReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CloseReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .state(self.state())
            .sig_a(self.sig_a())
            .sig_b(self.sig_b())
    }
}
#[derive(Clone, Copy)]
pub struct CloseReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "state", self.state())?;
        write!(f, ", {}: {}", "sig_a", self.sig_a())?;
        write!(f, ", {}: {}", "sig_b", self.sig_b())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CloseReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn state(&self) -> ChannelStateReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelStateReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sig_a(&self) -> SignatureReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        SignatureReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn sig_b(&self) -> SignatureReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            SignatureReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SignatureReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CloseReader<'r> {
    type Entity = Close;
    const NAME: &'static str = "CloseReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CloseReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ChannelStateReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SignatureReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        SignatureReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CloseBuilder {
    pub(crate) state: ChannelState,
    pub(crate) sig_a: Signature,
    pub(crate) sig_b: Signature,
}
impl CloseBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn state(mut self, v: ChannelState) -> Self {
        self.state = v;
        self
    }
    pub fn sig_a(mut self, v: Signature) -> Self {
        self.sig_a = v;
        self
    }
    pub fn sig_b(mut self, v: Signature) -> Self {
        self.sig_b = v;
        self
    }
}
impl molecule::prelude::Builder for CloseBuilder {
    type Entity = Close;
    const NAME: &'static str = "CloseBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.state.as_slice().len()
            + self.sig_a.as_slice().len()
            + self.sig_b.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.state.as_slice().len();
        offsets.push(total_size);
        total_size += self.sig_a.as_slice().len();
        offsets.push(total_size);
        total_size += self.sig_b.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.state.as_slice())?;
        writer.write_all(self.sig_a.as_slice())?;
        writer.write_all(self.sig_b.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Close::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ForceClose(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ForceClose {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ForceClose {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ForceClose {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for ForceClose {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        ForceClose::new_unchecked(v.into())
    }
}
impl ForceClose {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> ForceCloseReader<'r> {
        ForceCloseReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ForceClose {
    type Builder = ForceCloseBuilder;
    const NAME: &'static str = "ForceClose";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ForceClose(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ForceCloseReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ForceCloseReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct ForceCloseReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ForceCloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ForceCloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ForceCloseReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> ForceCloseReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for ForceCloseReader<'r> {
    type Entity = ForceClose;
    const NAME: &'static str = "ForceCloseReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ForceCloseReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct ForceCloseBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for ForceCloseBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for ForceCloseBuilder {
    fn default() -> Self {
        ForceCloseBuilder([Byte::default()])
    }
}
impl ForceCloseBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for ForceCloseBuilder {
    type Entity = ForceClose;
    const NAME: &'static str = "ForceCloseBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ForceClose::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelWitness(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelWitness {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelWitness {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelWitness {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for ChannelWitness {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 13, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0];
        ChannelWitness::new_unchecked(v.into())
    }
}
impl ChannelWitness {
    pub const ITEMS_COUNT: usize = 5;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> ChannelWitnessUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => Fund::new_unchecked(inner).into(),
            1 => Abort::new_unchecked(inner).into(),
            2 => Dispute::new_unchecked(inner).into(),
            3 => Close::new_unchecked(inner).into(),
            4 => ForceClose::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelWitnessReader<'r> {
        ChannelWitnessReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelWitness {
    type Builder = ChannelWitnessBuilder;
    const NAME: &'static str = "ChannelWitness";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelWitness(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelWitnessReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelWitnessReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelWitnessReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelWitnessReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelWitnessReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelWitnessReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> ChannelWitnessReader<'r> {
    pub const ITEMS_COUNT: usize = 5;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> ChannelWitnessUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => FundReader::new_unchecked(inner).into(),
            1 => AbortReader::new_unchecked(inner).into(),
            2 => DisputeReader::new_unchecked(inner).into(),
            3 => CloseReader::new_unchecked(inner).into(),
            4 => ForceCloseReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelWitnessReader<'r> {
    type Entity = ChannelWitness;
    const NAME: &'static str = "ChannelWitnessReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelWitnessReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => FundReader::verify(inner_slice, compatible),
            1 => AbortReader::verify(inner_slice, compatible),
            2 => DisputeReader::verify(inner_slice, compatible),
            3 => CloseReader::verify(inner_slice, compatible),
            4 => ForceCloseReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelWitnessBuilder(pub(crate) ChannelWitnessUnion);
impl ChannelWitnessBuilder {
    pub const ITEMS_COUNT: usize = 5;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<ChannelWitnessUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for ChannelWitnessBuilder {
    type Entity = ChannelWitness;
    const NAME: &'static str = "ChannelWitnessBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelWitness::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum ChannelWitnessUnion {
    Fund(Fund),
    Abort(Abort),
    Dispute(Dispute),
    Close(Close),
    ForceClose(ForceClose),
}
#[derive(Debug, Clone, Copy)]
pub enum ChannelWitnessUnionReader<'r> {
    Fund(FundReader<'r>),
    Abort(AbortReader<'r>),
    Dispute(DisputeReader<'r>),
    Close(CloseReader<'r>),
    ForceClose(ForceCloseReader<'r>),
}
impl ::core::default::Default for ChannelWitnessUnion {
    fn default() -> Self {
        ChannelWitnessUnion::Fund(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for ChannelWitnessUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ChannelWitnessUnion::Fund(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Fund::NAME, item)
            }
            ChannelWitnessUnion::Abort(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Abort::NAME, item)
            }
            ChannelWitnessUnion::Dispute(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Dispute::NAME, item)
            }
            ChannelWitnessUnion::Close(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Close::NAME, item)
            }
            ChannelWitnessUnion::ForceClose(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ForceClose::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for ChannelWitnessUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ChannelWitnessUnionReader::Fund(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Fund::NAME, item)
            }
            ChannelWitnessUnionReader::Abort(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Abort::NAME, item)
            }
            ChannelWitnessUnionReader::Dispute(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Dispute::NAME, item)
            }
            ChannelWitnessUnionReader::Close(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, Close::NAME, item)
            }
            ChannelWitnessUnionReader::ForceClose(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ForceClose::NAME, item)
            }
        }
    }
}
impl ChannelWitnessUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ChannelWitnessUnion::Fund(ref item) => write!(f, "{}", item),
            ChannelWitnessUnion::Abort(ref item) => write!(f, "{}", item),
            ChannelWitnessUnion::Dispute(ref item) => write!(f, "{}", item),
            ChannelWitnessUnion::Close(ref item) => write!(f, "{}", item),
            ChannelWitnessUnion::ForceClose(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> ChannelWitnessUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ChannelWitnessUnionReader::Fund(ref item) => write!(f, "{}", item),
            ChannelWitnessUnionReader::Abort(ref item) => write!(f, "{}", item),
            ChannelWitnessUnionReader::Dispute(ref item) => write!(f, "{}", item),
            ChannelWitnessUnionReader::Close(ref item) => write!(f, "{}", item),
            ChannelWitnessUnionReader::ForceClose(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<Fund> for ChannelWitnessUnion {
    fn from(item: Fund) -> Self {
        ChannelWitnessUnion::Fund(item)
    }
}
impl ::core::convert::From<Abort> for ChannelWitnessUnion {
    fn from(item: Abort) -> Self {
        ChannelWitnessUnion::Abort(item)
    }
}
impl ::core::convert::From<Dispute> for ChannelWitnessUnion {
    fn from(item: Dispute) -> Self {
        ChannelWitnessUnion::Dispute(item)
    }
}
impl ::core::convert::From<Close> for ChannelWitnessUnion {
    fn from(item: Close) -> Self {
        ChannelWitnessUnion::Close(item)
    }
}
impl ::core::convert::From<ForceClose> for ChannelWitnessUnion {
    fn from(item: ForceClose) -> Self {
        ChannelWitnessUnion::ForceClose(item)
    }
}
impl<'r> ::core::convert::From<FundReader<'r>> for ChannelWitnessUnionReader<'r> {
    fn from(item: FundReader<'r>) -> Self {
        ChannelWitnessUnionReader::Fund(item)
    }
}
impl<'r> ::core::convert::From<AbortReader<'r>> for ChannelWitnessUnionReader<'r> {
    fn from(item: AbortReader<'r>) -> Self {
        ChannelWitnessUnionReader::Abort(item)
    }
}
impl<'r> ::core::convert::From<DisputeReader<'r>> for ChannelWitnessUnionReader<'r> {
    fn from(item: DisputeReader<'r>) -> Self {
        ChannelWitnessUnionReader::Dispute(item)
    }
}
impl<'r> ::core::convert::From<CloseReader<'r>> for ChannelWitnessUnionReader<'r> {
    fn from(item: CloseReader<'r>) -> Self {
        ChannelWitnessUnionReader::Close(item)
    }
}
impl<'r> ::core::convert::From<ForceCloseReader<'r>> for ChannelWitnessUnionReader<'r> {
    fn from(item: ForceCloseReader<'r>) -> Self {
        ChannelWitnessUnionReader::ForceClose(item)
    }
}
impl ChannelWitnessUnion {
    pub const NAME: &'static str = "ChannelWitnessUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            ChannelWitnessUnion::Fund(item) => item.as_bytes(),
            ChannelWitnessUnion::Abort(item) => item.as_bytes(),
            ChannelWitnessUnion::Dispute(item) => item.as_bytes(),
            ChannelWitnessUnion::Close(item) => item.as_bytes(),
            ChannelWitnessUnion::ForceClose(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            ChannelWitnessUnion::Fund(item) => item.as_slice(),
            ChannelWitnessUnion::Abort(item) => item.as_slice(),
            ChannelWitnessUnion::Dispute(item) => item.as_slice(),
            ChannelWitnessUnion::Close(item) => item.as_slice(),
            ChannelWitnessUnion::ForceClose(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            ChannelWitnessUnion::Fund(_) => 0,
            ChannelWitnessUnion::Abort(_) => 1,
            ChannelWitnessUnion::Dispute(_) => 2,
            ChannelWitnessUnion::Close(_) => 3,
            ChannelWitnessUnion::ForceClose(_) => 4,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            ChannelWitnessUnion::Fund(_) => "Fund",
            ChannelWitnessUnion::Abort(_) => "Abort",
            ChannelWitnessUnion::Dispute(_) => "Dispute",
            ChannelWitnessUnion::Close(_) => "Close",
            ChannelWitnessUnion::ForceClose(_) => "ForceClose",
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelWitnessUnionReader<'r> {
        match self {
            ChannelWitnessUnion::Fund(item) => item.as_reader().into(),
            ChannelWitnessUnion::Abort(item) => item.as_reader().into(),
            ChannelWitnessUnion::Dispute(item) => item.as_reader().into(),
            ChannelWitnessUnion::Close(item) => item.as_reader().into(),
            ChannelWitnessUnion::ForceClose(item) => item.as_reader().into(),
        }
    }
}
impl<'r> ChannelWitnessUnionReader<'r> {
    pub const NAME: &'r str = "ChannelWitnessUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            ChannelWitnessUnionReader::Fund(item) => item.as_slice(),
            ChannelWitnessUnionReader::Abort(item) => item.as_slice(),
            ChannelWitnessUnionReader::Dispute(item) => item.as_slice(),
            ChannelWitnessUnionReader::Close(item) => item.as_slice(),
            ChannelWitnessUnionReader::ForceClose(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            ChannelWitnessUnionReader::Fund(_) => 0,
            ChannelWitnessUnionReader::Abort(_) => 1,
            ChannelWitnessUnionReader::Dispute(_) => 2,
            ChannelWitnessUnionReader::Close(_) => 3,
            ChannelWitnessUnionReader::ForceClose(_) => 4,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            ChannelWitnessUnionReader::Fund(_) => "Fund",
            ChannelWitnessUnionReader::Abort(_) => "Abort",
            ChannelWitnessUnionReader::Dispute(_) => "Dispute",
            ChannelWitnessUnionReader::Close(_) => "Close",
            ChannelWitnessUnionReader::ForceClose(_) => "ForceClose",
        }
    }
}
#[derive(Clone)]
pub struct ChannelState(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "balances", self.balances())?;
        write!(f, ", {}: {}", "version", self.version())?;
        write!(f, ", {}: {}", "is_final", self.is_final())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelState {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            97, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        ChannelState::new_unchecked(v.into())
    }
}
impl ChannelState {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn balances(&self) -> Balances {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Balances::new_unchecked(self.0.slice(start..end))
    }
    pub fn version(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn is_final(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Bool::new_unchecked(self.0.slice(start..end))
        } else {
            Bool::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelStateReader<'r> {
        ChannelStateReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelState {
    type Builder = ChannelStateBuilder;
    const NAME: &'static str = "ChannelState";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelState(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelStateReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelStateReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .channel_id(self.channel_id())
            .balances(self.balances())
            .version(self.version())
            .is_final(self.is_final())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelStateReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "channel_id", self.channel_id())?;
        write!(f, ", {}: {}", "balances", self.balances())?;
        write!(f, ", {}: {}", "version", self.version())?;
        write!(f, ", {}: {}", "is_final", self.is_final())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelStateReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn channel_id(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn balances(&self) -> BalancesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BalancesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn version(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn is_final(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            BoolReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BoolReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelStateReader<'r> {
    type Entity = ChannelState;
    const NAME: &'static str = "ChannelStateReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelStateReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BalancesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        BoolReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelStateBuilder {
    pub(crate) channel_id: Byte32,
    pub(crate) balances: Balances,
    pub(crate) version: Uint64,
    pub(crate) is_final: Bool,
}
impl ChannelStateBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn channel_id(mut self, v: Byte32) -> Self {
        self.channel_id = v;
        self
    }
    pub fn balances(mut self, v: Balances) -> Self {
        self.balances = v;
        self
    }
    pub fn version(mut self, v: Uint64) -> Self {
        self.version = v;
        self
    }
    pub fn is_final(mut self, v: Bool) -> Self {
        self.is_final = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelStateBuilder {
    type Entity = ChannelState;
    const NAME: &'static str = "ChannelStateBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.channel_id.as_slice().len()
            + self.balances.as_slice().len()
            + self.version.as_slice().len()
            + self.is_final.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.channel_id.as_slice().len();
        offsets.push(total_size);
        total_size += self.balances.as_slice().len();
        offsets.push(total_size);
        total_size += self.version.as_slice().len();
        offsets.push(total_size);
        total_size += self.is_final.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.channel_id.as_slice())?;
        writer.write_all(self.balances.as_slice())?;
        writer.write_all(self.version.as_slice())?;
        writer.write_all(self.is_final.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelState::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelStatus(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "state", self.state())?;
        write!(f, ", {}: {}", "timestamp", self.timestamp())?;
        write!(f, ", {}: {}", "funded", self.funded())?;
        write!(f, ", {}: {}", "funding", self.funding())?;
        write!(f, ", {}: {}", "disputed", self.disputed())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelStatus {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            171, 0, 0, 0, 24, 0, 0, 0, 121, 0, 0, 0, 129, 0, 0, 0, 134, 0, 0, 0, 166, 0, 0, 0, 97,
            0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,
        ];
        ChannelStatus::new_unchecked(v.into())
    }
}
impl ChannelStatus {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn state(&self) -> ChannelState {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelState::new_unchecked(self.0.slice(start..end))
    }
    pub fn timestamp(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn funded(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Bool::new_unchecked(self.0.slice(start..end))
    }
    pub fn funding(&self) -> Balances {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Balances::new_unchecked(self.0.slice(start..end))
    }
    pub fn disputed(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            Bool::new_unchecked(self.0.slice(start..end))
        } else {
            Bool::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> ChannelStatusReader<'r> {
        ChannelStatusReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelStatus {
    type Builder = ChannelStatusBuilder;
    const NAME: &'static str = "ChannelStatus";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelStatus(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelStatusReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelStatusReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .state(self.state())
            .timestamp(self.timestamp())
            .funded(self.funded())
            .funding(self.funding())
            .disputed(self.disputed())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelStatusReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelStatusReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelStatusReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelStatusReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "state", self.state())?;
        write!(f, ", {}: {}", "timestamp", self.timestamp())?;
        write!(f, ", {}: {}", "funded", self.funded())?;
        write!(f, ", {}: {}", "funding", self.funding())?;
        write!(f, ", {}: {}", "disputed", self.disputed())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ChannelStatusReader<'r> {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn state(&self) -> ChannelStateReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ChannelStateReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn timestamp(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn funded(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        BoolReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn funding(&self) -> BalancesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        BalancesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn disputed(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            BoolReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BoolReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelStatusReader<'r> {
    type Entity = ChannelStatus;
    const NAME: &'static str = "ChannelStatusReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelStatusReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ChannelStateReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BoolReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        BalancesReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        BoolReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelStatusBuilder {
    pub(crate) state: ChannelState,
    pub(crate) timestamp: Uint64,
    pub(crate) funded: Bool,
    pub(crate) funding: Balances,
    pub(crate) disputed: Bool,
}
impl ChannelStatusBuilder {
    pub const FIELD_COUNT: usize = 5;
    pub fn state(mut self, v: ChannelState) -> Self {
        self.state = v;
        self
    }
    pub fn timestamp(mut self, v: Uint64) -> Self {
        self.timestamp = v;
        self
    }
    pub fn funded(mut self, v: Bool) -> Self {
        self.funded = v;
        self
    }
    pub fn funding(mut self, v: Balances) -> Self {
        self.funding = v;
        self
    }
    pub fn disputed(mut self, v: Bool) -> Self {
        self.disputed = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelStatusBuilder {
    type Entity = ChannelStatus;
    const NAME: &'static str = "ChannelStatusBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.state.as_slice().len()
            + self.timestamp.as_slice().len()
            + self.funded.as_slice().len()
            + self.funding.as_slice().len()
            + self.disputed.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.state.as_slice().len();
        offsets.push(total_size);
        total_size += self.timestamp.as_slice().len();
        offsets.push(total_size);
        total_size += self.funded.as_slice().len();
        offsets.push(total_size);
        total_size += self.funding.as_slice().len();
        offsets.push(total_size);
        total_size += self.disputed.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.state.as_slice())?;
        writer.write_all(self.timestamp.as_slice())?;
        writer.write_all(self.funded.as_slice())?;
        writer.write_all(self.funding.as_slice())?;
        writer.write_all(self.disputed.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelStatus::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ChannelToken(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ChannelToken {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ChannelToken {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ChannelToken {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "out_point", self.out_point())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for ChannelToken {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,
        ];
        ChannelToken::new_unchecked(v.into())
    }
}
impl ChannelToken {
    pub const TOTAL_SIZE: usize = 36;
    pub const FIELD_SIZES: [usize; 1] = [36];
    pub const FIELD_COUNT: usize = 1;
    pub fn out_point(&self) -> OutPoint {
        OutPoint::new_unchecked(self.0.slice(0..36))
    }
    pub fn as_reader<'r>(&'r self) -> ChannelTokenReader<'r> {
        ChannelTokenReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ChannelToken {
    type Builder = ChannelTokenBuilder;
    const NAME: &'static str = "ChannelToken";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ChannelToken(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelTokenReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ChannelTokenReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().out_point(self.out_point())
    }
}
#[derive(Clone, Copy)]
pub struct ChannelTokenReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ChannelTokenReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ChannelTokenReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ChannelTokenReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "out_point", self.out_point())?;
        write!(f, " }}")
    }
}
impl<'r> ChannelTokenReader<'r> {
    pub const TOTAL_SIZE: usize = 36;
    pub const FIELD_SIZES: [usize; 1] = [36];
    pub const FIELD_COUNT: usize = 1;
    pub fn out_point(&self) -> OutPointReader<'r> {
        OutPointReader::new_unchecked(&self.as_slice()[0..36])
    }
}
impl<'r> molecule::prelude::Reader<'r> for ChannelTokenReader<'r> {
    type Entity = ChannelToken;
    const NAME: &'static str = "ChannelTokenReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ChannelTokenReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ChannelTokenBuilder {
    pub(crate) out_point: OutPoint,
}
impl ChannelTokenBuilder {
    pub const TOTAL_SIZE: usize = 36;
    pub const FIELD_SIZES: [usize; 1] = [36];
    pub const FIELD_COUNT: usize = 1;
    pub fn out_point(mut self, v: OutPoint) -> Self {
        self.out_point = v;
        self
    }
}
impl molecule::prelude::Builder for ChannelTokenBuilder {
    type Entity = ChannelToken;
    const NAME: &'static str = "ChannelTokenBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.out_point.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ChannelToken::new_unchecked(inner.into())
    }
}
