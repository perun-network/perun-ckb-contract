use crate::perun::mutators::*;
use crate::perun::random;

use super::*;
use ckb_occupied_capacity::Capacity;
use ckb_testtool::ckb_types::{bytes::Bytes, packed::*, prelude::*};
use ckb_testtool::context::Context;
use perun;
use perun::test;
use perun_common::helpers::blake2b256;
use perun_common::perun_types::{Balances, Bool, ChannelState, SEC1EncodedPubKey, CKByteDistribution};
use perun_common::sig::verify_signature;

const MAX_CYCLES: u64 = 10 * 10_000_000;
const CHALLENGE_DURATION_MS: u64 = 10 * 1000;

#[test]
fn test_signature() {
    // This tests the interoperability between the on-chain signature verification
    // and the key generation & signing in the perun-ckb-backend's wallet.

    // This signature was generated by the wallet in the perun-ckb-backend
    let sig_string = "3045022100a4f8768be2e5afdcbcfee600eb963caf1957d32edca49390e6f5a4933c2f6dcd02207fd9d2b5928266e9aeee039285508da1dbdbeec67cb995fd8735e1795bf53e5f";
    let sig = hex::decode(sig_string).expect("decoding signature");
    let sig_bytes: Bytes = sig.into();

    // This public key was generated by the wallet in the perun-ckb-backend
    let pubkey_string = "02d1ab4e7cbfb2262de6f3f816d9b044970162a6a2ae0e6b0ff9b082e315c5e152";
    let pubkey = hex::decode(pubkey_string).expect("decoding pubkey");
    let pubkey_bytes: [Byte; 33] = pubkey
        .iter()
        .map(|x| (*x).into())
        .collect::<Vec<Byte>>()
        .try_into()
        .unwrap();
    SEC1EncodedPubKey::new_builder().set(pubkey_bytes).build();

    let balances_array: [Uint64; 2] = [10u64.pack(), 11u64.pack()];
    let balances = Balances::new_builder().ckbytes(CKByteDistribution::new_builder().set(balances_array).build()).build();
    let channel_state = ChannelState::new_builder()
        .channel_id(Byte32::zero())
        .balances(balances)
        .is_final(Bool::from_bool(true))
        .version(10u64.pack())
        .build();
    let msg = channel_state.as_slice();
    let msg_hash = blake2b256(msg);

    verify_signature(&msg_hash, &sig_bytes, pubkey.as_slice()).expect("valid signature");
}

// TODO: Add mutator to channel state that can be passed to dispute, and close.
#[test]
fn channel_test_bench() -> Result<(), perun::Error> {
    let res = [
        test_funding_abort,
        test_successful_funding_with_udt,
        test_successful_funding_without_udt,
        test_early_force_close,
        test_close,
        test_force_close,
        test_multiple_disputes,
        test_multiple_disputes_same_version,
        test_multi_asset_payment,
    ]
    .iter()
    .map(|test| {
        let mut context = Context::default();
        let pe = perun::harness::Env::new(&mut context, MAX_CYCLES, CHALLENGE_DURATION_MS)
            .expect("preparing environment");
        test(&mut context, &pe)
    })
    .collect::<Vec<_>>();
    res.into_iter().collect()
}

fn create_channel_test(
    context: &mut Context,
    env: &perun::harness::Env,
    parts: &[perun::TestAccount],
    test: impl Fn(&mut perun::channel::Channel<perun::State>) -> Result<(), perun::Error>,
) -> Result<(), perun::Error> {
    let mut chan = perun::channel::Channel::new(context, env, parts);
    test(&mut chan)
}

fn test_funding_abort(
    context: &mut Context,
    env: &perun::harness::Env,
) -> Result<(), perun::Error> {
    let (alice, bob) = ("alice", "bob");
    let parts = [random::account(alice), random::account(bob)];
    let funding_timeout = 10;
    let funding = [
        Capacity::bytes(1000)?.as_u64(),
        Capacity::bytes(1000)?.as_u64(),
    ];
    let funding_agreement = test::FundingAgreement::new_with_capacities(
        parts.iter().cloned().zip(funding.iter().cloned()).collect(),
    );
    create_channel_test(context, env, &parts, |chan| {
        chan.with(alice)
            .open(&funding_agreement)
            .expect("opening channel");

        chan.delay(funding_timeout);

        chan.with(alice).abort().expect("aborting channel");

        chan.assert();
        Ok(())
    })
}

fn test_successful_funding_without_udt(
    context: &mut Context,
    env: &perun::harness::Env,
) -> Result<(), perun::Error> {
    let (alice, bob) = ("alice", "bob");
    let parts = [random::account(alice), random::account(bob)];
    let funding = [
        Capacity::bytes(100)?.as_u64(),
        Capacity::bytes(100)?.as_u64(),
    ];
    let funding_agreement = test::FundingAgreement::new_with_capacities(
        parts.iter().cloned().zip(funding.iter().cloned()).collect(),
    );
    create_channel_test(context, env, &parts, |chan| {
        chan.with(alice)
            .open(&funding_agreement)
            .expect("opening channel");

        chan.with(bob)
            .fund(&funding_agreement)
            .expect("funding channel");

        chan.assert();
        Ok(())
    })
}


fn test_successful_funding_with_udt(
    context: &mut Context,
    env: &perun::harness::Env,
) -> Result<(), perun::Error> {
    let (alice, bob) = ("alice", "bob");
    let parts = [random::account(alice), random::account(bob)];
    let funding = [
        Capacity::bytes(100)?.as_u64(),
        Capacity::bytes(100)?.as_u64(),
    ];
    let asset_funding = [
        20u128,
        30u128,
    ];
    let funding_agreement = test::FundingAgreement::new_with_capacities_and_sudt(
        parts.iter().cloned().zip(funding.iter().cloned()).collect(),
        &env.sample_udt_script,
        env.sample_udt_max_cap.as_u64(),
        parts.iter().cloned().zip(asset_funding.iter().cloned()).collect(),
    );
    create_channel_test(context, env, &parts, |chan| {
        chan.with(alice)
            .open(&funding_agreement)
            .expect("opening channel");

        chan.with(bob)
            .fund(&funding_agreement)
            .expect("funding channel");

        chan.assert();
        Ok(())
    })
}

fn test_close(context: &mut Context, env: &perun::harness::Env) -> Result<(), perun::Error> {
    let (alice, bob) = ("alice", "bob");
    let parts = [random::account(alice), random::account(bob)];
    let funding = [
        Capacity::bytes(100)?.as_u64(),
        Capacity::bytes(100)?.as_u64(),
    ];
    let funding_agreement = test::FundingAgreement::new_with_capacities(
        parts.iter().cloned().zip(funding.iter().cloned()).collect(),
    );
    create_channel_test(context, env, &parts, |chan| {
        chan.with(alice)
            .open(&funding_agreement)
            .expect("opening channel");

        chan.with(bob)
            .fund(&funding_agreement)
            .expect("funding channel");

        chan.with(alice)
            .finalize()
            .close()
            .expect("closing channel");

        chan.assert();
        Ok(())
    })
}

fn test_force_close(context: &mut Context, env: &perun::harness::Env) -> Result<(), perun::Error> {
    let (alice, bob) = ("alice", "bob");
    let parts = [random::account(alice), random::account(bob)];
    let funding = [
        Capacity::bytes(100)?.as_u64(),
        Capacity::bytes(100)?.as_u64(),
    ];
    let funding_agreement = test::FundingAgreement::new_with_capacities(
        parts.iter().cloned().zip(funding.iter().cloned()).collect(),
    );
    create_channel_test(context, env, &parts, |chan| {
        chan.with(alice)
            .open(&funding_agreement)
            .expect("opening channel");

        chan.with(bob)
            .fund(&funding_agreement)
            .expect("funding channel");

        chan.with(bob).dispute().expect("invalid channel dispute");

        chan.delay(env.challenge_duration);

        chan.with(bob).force_close().expect("force closing channel");

        chan.assert();
        Ok(())
    })
}

fn test_early_force_close(context: &mut Context, env: &perun::harness::Env) -> Result<(), perun::Error> {
    let (alice, bob) = ("alice", "bob");
    let parts = [random::account(alice), random::account(bob)];
    let funding = [
        Capacity::bytes(100)?.as_u64(),
        Capacity::bytes(100)?.as_u64(),
    ];
    let funding_agreement = test::FundingAgreement::new_with_capacities(
        parts.iter().cloned().zip(funding.iter().cloned()).collect(),
    );
    create_channel_test(context, env, &parts, |chan| {
        chan.with(alice)
            .open(&funding_agreement)
            .expect("opening channel");

        chan.with(bob)
            .fund(&funding_agreement)
            .expect("funding channel");

        chan.with(bob).dispute().expect("invalid channel dispute");

        chan.with(bob).invalid().force_close().expect("force closing channel");

        chan.assert();
        Ok(())
    })
}

fn test_multiple_disputes_same_version(
    context: &mut Context,
    env: &perun::harness::Env,
) -> Result<(), perun::Error> {
    let (alice, bob) = ("alice", "bob");
    let parts = [random::account(alice), random::account(bob)];
    let funding = [
        Capacity::bytes(100)?.as_u64(),
        Capacity::bytes(100)?.as_u64(),
    ];
    let funding_agreement = test::FundingAgreement::new_with_capacities(
        parts.iter().cloned().zip(funding.iter().cloned()).collect(),
    );
    create_channel_test(context, env, &parts, |chan| {
        chan.with(alice)
            .open(&funding_agreement)
            .expect("opening channel");

        chan.with(bob)
            .fund(&funding_agreement)
            .expect("funding channel");

        chan.with(alice)
            .valid()
            .dispute()
            .expect("disputing channel");

        chan.with(bob)
            .invalid()
            .dispute()
            .expect("disputing channel");

        chan.assert();
        Ok(())
    })
}

fn test_multiple_disputes(
    context: &mut Context,
    env: &perun::harness::Env,
) -> Result<(), perun::Error> {
    let (alice, bob) = ("alice", "bob");
    let parts = [random::account(alice), random::account(bob)];
    let funding = [
        Capacity::bytes(100)?.as_u64(),
        Capacity::bytes(100)?.as_u64(),
    ];
    let funding_agreement = test::FundingAgreement::new_with_capacities(
        parts.iter().cloned().zip(funding.iter().cloned()).collect(),
    );
    create_channel_test(context, env, &parts, |chan| {
        chan.with(alice)
            .open(&funding_agreement)
            .expect("opening channel");

        chan.with(bob)
            .fund(&funding_agreement)
            .expect("funding channel");

        chan.with(alice)
            .valid()
            .dispute()
            .expect("disputing channel");

        chan.with(bob)
            .valid()
            .update(bump_version())
            .dispute()
            .expect("disputing channel");

        chan.assert();
        Ok(())
    })
}

fn test_multi_asset_payment(
    context: &mut Context,
    env: &perun::harness::Env,
) -> Result<(), perun::Error> {
    let (alice, bob) = ("alice", "bob");
    let parts = [random::account(alice), random::account(bob)];
    let funding = [
        Capacity::bytes(100)?.as_u64(),
        Capacity::bytes(100)?.as_u64(),
    ];
    let asset_funding = [
        20u128,
        30u128,
    ];
    let funding_agreement = test::FundingAgreement::new_with_capacities_and_sudt(
        parts.iter().cloned().zip(funding.iter().cloned()).collect(),
        &env.sample_udt_script,
        env.sample_udt_max_cap.as_u64(),
        parts.iter().cloned().zip(asset_funding.iter().cloned()).collect(),
    );
    create_channel_test(context, env, &parts, |chan| {
        chan.with(alice)
            .open(&funding_agreement)
            .expect("opening channel");

        chan.with(bob)
            .fund(&funding_agreement)
            .expect("funding channel");

        chan.update(pay_ckbytes(Direction::AtoB, 50));
        chan.update(pay_sudt(Direction::BtoA, 10, 0));

        chan.with(alice).finalize().close().expect("closing channel");

        chan.assert();
        Ok(())
    })
}
